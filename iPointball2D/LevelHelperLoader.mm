//  This file was generated by LevelHelper
//  http://www.levelhelper.org
//
//  LevelHelperLoader.mm
//  Created by Bogdan Vladu
//  Copyright 2011 Bogdan Vladu. All rights reserved.
////////////////////////////////////////////////////////////////////////////////
//
//  This software is provided 'as-is', without any express or implied
//  warranty.  In no event will the authors be held liable for any damages
//  arising from the use of this software.
//  Permission is granted to anyone to use this software for any purpose,
//  including commercial applications, and to alter it and redistribute it
//  freely, subject to the following restrictions:
//  The origin of this software must not be misrepresented; you must not
//  claim that you wrote the original software. If you use this software
//  in a product, an acknowledgment in the product documentation would be
//  appreciated but is not required.
//  Altered source versions must be plainly marked as such, and must not be
//  misrepresented as being the original software.
//  This notice may not be removed or altered from any source distribution.
//  By "software" the author refers to this code file and not the application 
//  that was used to generate this file.
//
////////////////////////////////////////////////////////////////////////////////

#import "LevelHelperLoader.h"
#import "CCParallaxNode.h"


float LH_PTM_RATIO = 32.0f;

/// converts degrees to radians
#define DEGREES_TO_RADIANS(__ANGLE__) ((__ANGLE__) / 180.0f * (float)M_PI)
/// converts radians to degrees
#define RADIANS_TO_DEGREES(__ANGLE__) ((__ANGLE__) / (float)M_PI * 180.0f)


#if TARGET_OS_EMBEDDED || TARGET_OS_IPHONE || TARGET_OS_WIN32 || NS_BUILD_32_LIKE_64

#define LHRectFromString(str) CGRectFromString(str)
#define LHPointFromString(str) CGPointFromString(str)
#define LHPoint CGPoint
#define LHRect  CGRect
#define LHMakePoint(x, y) CGPointMake(x, y)

CGPoint LHPointFromValue(NSValue* val)
{
    return [val CGPointValue];
}

NSValue* LHValueWithRect(CGRect rect)
{
    return [NSValue valueWithCGRect:rect];
}

NSValue* LHValueWithPoint(CGPoint pt)
{
    return [NSValue valueWithCGPoint:pt];
}

CGRect LHRectFromValue(NSValue* val)
{
    return [val CGRectValue];
}

#else

#define LHRectFromString(str) NSRectToCGRect(NSRectFromString(str))
#define LHPointFromString(str) NSPointToCGPoint(NSPointFromString(str))
#define LHPoint NSPoint
#define LHRect NSRect
#define LHMakePoint(x, y) NSMakePoint(x, y)

CGPoint LHPointFromValue(NSValue* val)
{
    NSPoint pt = [val pointValue];
    return CGPointMake(pt.x, pt.y);
}

NSValue* LHValueWithRect(CGRect rect)
{
    return [NSValue valueWithRect:NSMakeRect(rect.origin.x, rect.origin.y, rect.size.width, rect.size.height)];
}

NSValue* LHValueWithPoint(NSPoint pt)
{
    return [NSValue valueWithPoint:pt];
}

NSValue* LHValueWithPoint(CGPoint pt)
{
    return [NSValue valueWithPoint:NSMakePoint(pt.x, pt.y)];
}

CGRect LHRectFromValue(NSValue* val)
{
    return NSRectToCGRect([val rectValue]);
}

#endif

struct LHJoint {
    int tag;
    LH_JOINT_TYPE type;
    NSString* uniqueName;
    void* userData; //put your custom data here
};
typedef struct LHJoint LHJoint;

struct LH_PATH_INFO {
    
    NSString* pathUniqueName;
    CCSprite* ccSprite;
    float interval;
    float elapsed;
    bool reversed;
    bool isCyclic;
    bool pathOtherEnd;
    bool firstTick;
    bool needsReversed;
    bool paused;
    int currentPoint;
    int startPoint;
};
typedef struct LH_PATH_INFO lhPathInfo;

enum LH_ACTIONS_TAGS
{
    LH_PATH_ACTION_TAG,
    LH_ANIM_ACTION_TAG
};

int newBodyNameId = 0;
bool useRetinaOnIpad = true;
float lh_customAlpha = 1.0f;
////////////////////////////////////////////////////////////////////////////////
@interface LevelHelperLoader (Private)

-(void) initObjects;

-(void) addBatchNodesToLayer:(CCLayer*)cocosLayer;

-(void) setFixtureDefPropertiesFromDictionary:(NSDictionary*)spritePhysic 
									  fixture:(b2FixtureDef*)shapeDef;

-(b2Body*) b2BodyFromDictionary:(NSDictionary*)spritePhysic
			   spriteProperties:(NSDictionary*)spriteProp
						   data:(CCSprite*)ccsprite 
						  world:(b2World*)world;

-(b2Joint*) b2JointFromDictionary:(NSDictionary*)dictionary 
								world:(b2World*)world;

-(void)loadLevelHelperSceneFile:(NSString*)levelFile 
					inDirectory:(NSString*)subfolder
				   imgSubfolder:(NSString*)imgFolder;

-(void) checkIfSpriteWasMovingOnPathAndRemoveIt:(CCSprite*)sprite;

-(void)loadLevelHelperSceneFileFromWebAddress:(NSString*)webaddress;

-(void)processLevelFileFromDictionary:(NSDictionary*)dictionary;

-(b2Body*) b2BezierBodyFromDictionary:(NSDictionary*)bezierDict world:(b2World*)world;

-(CCParallaxNode*) parallaxNodeFromDictionary:(NSDictionary*)parallaxDict 
                                        layer:(CCLayer*)layer
                                     saveDict:(NSMutableDictionary*)saveInfo;

-(void) createPathOnSprite:(CCSprite*)ccsprite 
            withProperties:(NSDictionary*)spriteProp;

-(void) createAnimOnSprite:(CCSprite*)ccsprite withProperties:(NSDictionary*)spriteProp;

-(void) createBezierPath:(NSDictionary*)bezierDict;

-(void)saveCCFramesRectForAnimation:(NSString*)uniqueName;

@end

@implementation LevelHelperLoader

+(void) useRetinaOnIpad:(bool)value
{
    useRetinaOnIpad = value;
}

-(bool)isIpad
{
    if(!useRetinaOnIpad)
    {
        return false;
    }
    
    #ifndef __MAC_OS_X_VERSION_MAX_ALLOWED

    
    #ifdef __IPHONE_OS_VERSION_MAX_ALLOWED
    #if __IPHONE_3_2 <= __IPHONE_OS_VERSION_MAX_ALLOWED
    
            UIDevice* thisDevice = [UIDevice currentDevice];
            
            if ([thisDevice respondsToSelector:@selector(userInterfaceIdiom)]) 
            {
                if(thisDevice.userInterfaceIdiom == UIUserInterfaceIdiomPad)
                {
                    return true;
                }
            }
            else
            {
                return false;
            }
    #else
            return false;
    #endif
    
    #endif
    
    #else
        return true;
    #endif
return false;
}

-(NSString*)imageFile:(NSString*)file
{
    if([self isIpad])
    {   
        NSRange lastPt = [file rangeOfString:@"." options:NSBackwardsSearch];
        if(lastPt.location != NSNotFound)
        {
            NSString *newstring = [file stringByReplacingCharactersInRange:lastPt
                                                                withString:@"-hd."];
            
            NSString *fullpath = [CCFileUtils fullPathFromRelativePath:newstring];
            
            if([[NSFileManager defaultManager] fileExistsAtPath:fullpath])
            {
                return newstring;
            }
            
            useRetinaOnIpad = false;
            return file;
            
        }
        
        return file;
    }
    
    return file;
}

////////////////////////////////////////////////////////////////////////////////
-(void) initObjects
{
    
 //   NSLog(@"LevelHelper WARNING: Code is still in testing. If you find any bugs please report it so I could fix it. I will remove this warning when the code has been fully tested. Thank you!");
    
	batchNodes = [[NSMutableDictionary alloc] init];	
	ccSpritesInScene = [[NSMutableDictionary alloc] init];
	noPhysicSprites = [[NSMutableDictionary alloc] init];
	ccJointsInScene = [[NSMutableDictionary alloc] init];
    ccParallaxInScene = [[NSMutableDictionary alloc] init];
    ccBeziersBodyInScene = [[NSMutableDictionary alloc] init];
    ccBezierPathsInScene = [[NSMutableDictionary alloc] init];
    ccFramesForAnimation = [[NSMutableDictionary alloc] init];
    
    moveOnPathInfo = [[NSMutableArray alloc] init];
    
	addSpritesToLayerWasUsed = false;
	addObjectsToWordWasUsed = false;
    convertLevel = true;
    
    LH_PTM_RATIO = 32.0f;
   // convertPhysic = false;
    
    notifOnLoopForeverAnim = false;
	wbBody = 0;
}
////////////////////////////////////////////////////////////////////////////////
-(id) initWithContentOfFile:(NSString*)levelFile
{
	NSAssert(nil!=levelFile, @"Invalid file given to LevelHelperLoader");
	
	if(!(self = [super init]))
	{
		NSLog(@"LevelHelperLoader ****ERROR**** : [super init] failer ***");
		return self;
	}
	
	[self initObjects];
	[self loadLevelHelperSceneFile:levelFile inDirectory:@"" imgSubfolder:@""];
	
	
	return self;
}
////////////////////////////////////////////////////////////////////////////////
-(id) initWithContentOfFileFromInternet:(NSString*)webAddress
{
	NSAssert(nil!=webAddress, @"Invalid file given to LevelHelperLoader");
	
	if(!(self = [super init]))
	{
		NSLog(@"LevelHelperLoader ****ERROR**** : [super init] failer ***");
		return self;
	}
	
	[self initObjects];
	[self loadLevelHelperSceneFileFromWebAddress:webAddress];
	
	return self;
}
////////////////////////////////////////////////////////////////////////////////
-(id) initWithContentOfFile:(NSString*)levelFile 
			 levelSubfolder:(NSString*)levelFolder
{
	NSAssert(nil!=levelFile, @"Invalid file given to LevelHelperLoader");
	
	if(!(self = [super init]))
	{
		NSLog(@"LevelHelperLoader ****ERROR**** : [super init] failer ***");
		return self;
	}
	
	[self initObjects];
	
	[self loadLevelHelperSceneFile:levelFile inDirectory:levelFolder imgSubfolder:@""];
	
	return self;
	
}
////////////////////////////////////////////////////////////////////////////////
-(void) convertLevel:(bool)value
{
    convertLevel = value;
}

-(void) updateConversionRatio
{
    CGSize winSize = [[CCDirector sharedDirector] winSize];
        
    convertRatio.x = winSize.width/safeFrame.x;
    convertRatio.y = winSize.height/safeFrame.y;
}

+(void) setCustomAlphaOnAll:(float)value
{
    lh_customAlpha = value;
}
////////////////////////////////////////////////////////////////////////////////
-(CCSpriteBatchNode*) batchNodeForFile:(NSString*) imageName
{
    NSDictionary* batchInfo = [batchNodes objectForKey:imageName];
    if(batchInfo != nil)
    {
        return [batchInfo objectForKey:@"CCBatchNode"];
    }
    return nil;
}
////////////////////////////////////////////////////////////////////////////////
-(NSArray*) batchNodesInLevel
{
    NSArray* keys = [batchNodes allKeys];
    
    NSMutableArray* batches = [[[NSMutableArray alloc] init] autorelease];
    for(NSString* img in keys)
    {
        NSDictionary* batchInfo = [batchNodes objectForKey:img];
        
        if(batchInfo != nil)
        {
            [batches addObject:[batchInfo objectForKey:@"CCBatchNode"]];
        }
    }
    
    return batches;
}
////////////////////////////////////////////////////////////////////////////////
+(void) setMeterRatio:(float)ratio //default is 32.0f
{
    LH_PTM_RATIO = ratio;
}
+(float) meterRatio
{
    return LH_PTM_RATIO;
}

-(float) pixelsToMeterRatio
{
    return LH_PTM_RATIO*convertRatio.x;
}

-(float) pointsToMeterRatio
{
    return LH_PTM_RATIO;
}

-(b2Vec2) pixelToMeters:(CGPoint)point
{
    return b2Vec2(point.x / [self pixelsToMeterRatio], point.y / [self pixelsToMeterRatio]);
}

-(b2Vec2) pointsToMeters:(CGPoint)point
{
    return b2Vec2(point.x / LH_PTM_RATIO, point.y / LH_PTM_RATIO);
}

-(CGPoint) metersToPoints:(b2Vec2)vec
{
    return CGPointMake(vec.x*LH_PTM_RATIO, vec.y*LH_PTM_RATIO);
}

-(CGPoint) metersToPixels:(b2Vec2)vec
{
    return ccpMult(CGPointMake(vec.x, vec.y), [self pixelsToMeterRatio]);
}

////////////////////////////////////////////////////////////////////////////////
+(NSString*) uniqueNameForSprite:(CCSprite*)sprite
{
    if(nil != sprite)
    {
        NSMutableDictionary* spriteUserData = (NSMutableDictionary*)[sprite userData];

        if(nil != spriteUserData)
            return [spriteUserData objectForKey:@"UniqueName"];
    }
    
    return nil;
}

+(void) setCustomValue:(id)value withKey:(NSString*)key onSprite:(CCSprite*)sprite
{
    if(nil != sprite)
    {
        NSMutableDictionary* spriteUserData = (NSMutableDictionary*)[sprite userData];
        
        if(nil != spriteUserData)
        {
            [spriteUserData setObject:value forKey:key];
        }
    }
}

+(id) customValueWithKey:(NSString*)key forSprite:(CCSprite*)sprite
{
    if(nil != sprite)
    {
        NSMutableDictionary* spriteUserData = (NSMutableDictionary*)[sprite userData];
        
        if(nil != spriteUserData)
            return [spriteUserData objectForKey:key];
    }
    
    return nil;    
}

+(NSString*) uniqueNameForBody:(b2Body*)body
{

    CCSprite* spr = [LevelHelperLoader spriteForBody:body];
    if(nil != spr)
    {
        return [LevelHelperLoader uniqueNameForSprite:spr];
    }
    
    return nil;
}

+(NSString*) uniqueNameForJoint:(b2Joint*)joint
{
    if(0 != joint)
    {
        LHJoint* data = (LHJoint*)joint->GetUserData();
        if(0 != data)
        {
            return data->uniqueName;
        }
    }
    return nil;
}

+(NSString*) animationNameOnBody:(b2Body*)body
{
    CCSprite* spr = [LevelHelperLoader spriteForBody:body];
    if(nil != spr)
    {
        return [LevelHelperLoader animationNameOnSprite:spr];
    }
    
    return nil;
}

+(NSString*) animationNameOnSprite:(CCSprite*)sprite
{
    if(nil != sprite)
    {
        NSMutableDictionary* spriteUserData = (NSMutableDictionary*)[sprite userData];
        
        return [spriteUserData objectForKey:@"AnimName"];
    }
    
    return nil;
}

+(int) currentFrameOnSprite:(CCSprite*)sprite
{
    if(nil != sprite)
    {
        NSMutableDictionary* spriteUserData = (NSMutableDictionary*)[sprite userData];
        
        return [[spriteUserData objectForKey:@"CurrentFrame"] intValue];
    }
    
    return -1;
}

+(int) currentFrameOnBody:(b2Body*)body
{
    CCSprite* spr = [LevelHelperLoader spriteForBody:body];
    if(nil != spr)
    {
        return [LevelHelperLoader currentFrameOnSprite:spr];
    }
    
    return -1;
}

+(int) tagForBody:(b2Body*)body
{
    if(0 != body)
    {
        CCSprite* spr = (CCSprite*)body->GetUserData();
        
        if(nil != spr)
        {
            return [spr tag];
        }
    }
    
    return -1;
}
+(int) tagForSprite:(CCSprite*)sprite
{
    if(nil != sprite)
        return [sprite tag];
    
    return -1;
}

////////////////////////////////////////////////////////////////////////////////
+(CCSprite*) spriteForBody:(b2Body*)body
{    
    if(0 != body)
    {
        return (CCSprite*)body->GetUserData();
    }
    
    return nil;
}

+(b2Body*) bodyForSprite:(CCSprite*)sprite
{
    
    if(nil != sprite)
    {
        NSMutableDictionary* spriteUserData = (NSMutableDictionary*)[sprite userData];
        
        return (b2Body*)[[spriteUserData objectForKey:@"Body"] pointerValue];
    }
    
    return 0;
}


////////////////////////////////////////////////////////////////////////////////
+(int) tagForJoint:(b2Joint*)joint
{
    if(0 != joint)
    {
        LHJoint* data = (LHJoint*)joint->GetUserData();
    
        if(nil != data)
        {
            return data->tag;
        }
    }
    
    return -1;
}

+(enum LH_JOINT_TYPE) typeForJoint:(b2Joint*)joint
{
    if(0 != joint)
    {
        LHJoint* data = (LHJoint*)joint->GetUserData();
        
        if(nil != data)
        {
            return data->type;
        }
    }
    return LH_UNKNOWN_TYPE;    
}
////////////////////////////////////////////////////////////////////////////////
-(void) addSpritesToLayer:(CCLayer*)_cocosLayer
{	
	NSAssert(addObjectsToWordWasUsed!=true, @"You can't use method addSpritesToLayer because you already used addObjectToWorld. Only one of the two can be used."); 
	NSAssert(addSpritesToLayerWasUsed!=true, @"You can't use method addSpritesToLayer again. You can only use it once. Create a new LevelHelperLoader object if you want to load the level again."); 
	
	addSpritesToLayerWasUsed = true;
	
	cocosLayer = _cocosLayer;
	
	[self addBatchNodesToLayer:cocosLayer];
	
    
    
    //we need to first create the path so we can assign the path to sprite on creation
    for(NSDictionary* bezierDict in lhBeziers)
    {
        //NSString* uniqueName = [bezierDict objectForKey:@"UniqueName"];
        if([[bezierDict objectForKey:@"IsPath"] boolValue])
        {
            [self createBezierPath:bezierDict];
        }
    }
    
    
	for(NSDictionary* dictionary in lhSprites)
	{
		NSDictionary* spriteProp = [dictionary objectForKey:@"GeneralProperties"];
		
		//find the coresponding batch node for this sprite
		NSDictionary* batchInfo = [batchNodes objectForKey:[spriteProp objectForKey:@"Image"]];
		CCSpriteBatchNode *batch = [batchInfo objectForKey:@"CCBatchNode"];
		
		if(nil != batch)
		{
			CCSprite* ccsprite = [self spriteWithBatchFromDictionary:spriteProp batchNode:batch];
			if(nil != ccsprite)
			{
				[batch addChild:ccsprite];
				[ccSpritesInScene setObject:ccsprite forKey:[spriteProp objectForKey:@"UniqueName"]];
                
                [self setCustomAttributesForNonPhysics:spriteProp
                                                sprite:ccsprite];
			}
            
            if(![[spriteProp objectForKey:@"PathName"] isEqualToString:@"None"])
            {
                //we have a path we need to follow
                [self createPathOnSprite:ccsprite
                          withProperties:spriteProp];
            }
            
            NSString* animName = [spriteProp objectForKey:@"AnimName"];
            if(![animName isEqualToString:@""])
            {
                //we have an animation we need to add to this sprite
                bool atStart = [[spriteProp objectForKey:@"AnimAtStart"] boolValue];
                if(atStart)
                {
                    [self createAnimOnSprite:ccsprite withProperties:spriteProp];
                }
                else
                {
                    [self saveCCFramesRectForAnimation:animName];
                }
            }
		}
	}
    
    for(NSDictionary* parallaxDict in lhParallax)
    {
        NSMutableDictionary* nodeInfo = [[[NSMutableDictionary alloc] init] autorelease];
        CCParallaxNode* node = [self parallaxNodeFromDictionary:parallaxDict layer:cocosLayer saveDict:nodeInfo];
        
        if(nil != node)
        {
            //[nodeInfo setObject:[parallaxDict objectForKey:@"ScrollSpeed"] forKey:@"ScrollSpeed"];
            [nodeInfo setObject:[parallaxDict objectForKey:@"ContinuousScrolling"] forKey:@"ContinuousScrolling"];
            [nodeInfo setObject:[parallaxDict objectForKey:@"Speed"] forKey:@"Speed"];
            [nodeInfo setObject:[parallaxDict objectForKey:@"Direction"] forKey:@"Direction"];
            [nodeInfo setObject:node forKey:@"Node"];
            [ccParallaxInScene setObject:nodeInfo forKey:[parallaxDict objectForKey:@"UniqueName"]];
        }
    }
}
////////////////////////////////////////////////////////////////////////////////
-(void) addObjectsToWorld:(b2World*)world 
			 cocos2dLayer:(CCLayer*)_cocosLayer
{
	
	NSAssert(addSpritesToLayerWasUsed!=true, @"You can't use method addObjectsToWorld because you already used addSpritesToLayer. Only one of the two can be used."); 
	NSAssert(addObjectsToWordWasUsed!=true, @"You can't use method addObjectsToWorld again. You can only use it once. Create a new LevelHelperLoader object if you want to load the level again."); 
	
	addObjectsToWordWasUsed = true;
	
	cocosLayer = _cocosLayer;
    box2dWorld = world;
	
	[self addBatchNodesToLayer:cocosLayer];
	
    
    //we need to first create the path so we can assign the path to sprite on creation
    for(NSDictionary* bezierDict in lhBeziers)
    {
        NSString* uniqueName = [bezierDict objectForKey:@"UniqueName"];
        if(![[bezierDict objectForKey:@"IsPath"] boolValue])
        {
            b2Body* body = [self b2BezierBodyFromDictionary:bezierDict
                                                      world:world];
            NSValue *value = [NSValue valueWithPointer:body];
            [ccBeziersBodyInScene setObject:value forKey:uniqueName];			
        }
        else
        {
            [self createBezierPath:bezierDict];
        }
    }
    
	for(NSDictionary* dictionary in lhSprites)
	{
		NSDictionary* spriteProp = [dictionary objectForKey:@"GeneralProperties"];
		NSDictionary* physicProp = [dictionary objectForKey:@"PhysicProperties"];
		
		//find the coresponding batch node for this sprite
		NSDictionary* batchInfo = [batchNodes objectForKey:[spriteProp objectForKey:@"Image"]];
		CCSpriteBatchNode *batch = [batchInfo objectForKey:@"CCBatchNode"];
		
		if(nil != batch)
		{
            if(![[spriteProp objectForKey:@"IsInParallax"] boolValue])
            {
                CCSprite* ccsprite = [self spriteWithBatchFromDictionary:spriteProp batchNode:batch];
                [batch addChild:ccsprite z:[[spriteProp objectForKey:@"ZOrder"] intValue]];
			
                NSString* uniqueName = [spriteProp objectForKey:@"UniqueName"];
                if([[physicProp objectForKey:@"Type"] intValue] != 3) //3 means no physic
                {
                    b2Body* body = [self b2BodyFromDictionary:physicProp
                                             spriteProperties:spriteProp
                                                         data:ccsprite 
                                                        world:world];
                    
                    NSValue *value = [NSValue valueWithPointer:body];
                    [ccSpritesInScene setObject:value forKey:uniqueName];			
                }
                else {
                    [noPhysicSprites setObject:ccsprite forKey:uniqueName];
                    [self setCustomAttributesForNonPhysics:spriteProp
                                                    sprite:ccsprite];
                }
                
                
                if(![[spriteProp objectForKey:@"PathName"] isEqualToString:@"None"])
                {
                    //we have a path we need to follow
                    [self createPathOnSprite:ccsprite
                              withProperties:spriteProp];
                }
                
                NSString* animName = [spriteProp objectForKey:@"AnimName"];
                if(![animName isEqualToString:@""])
                {
                    //we have an animation we need to add to this sprite
                    bool atStart = [[spriteProp objectForKey:@"AnimAtStart"] boolValue];
                    if(atStart)
                    {
                        [self createAnimOnSprite:ccsprite withProperties:spriteProp];
                    }
                    else
                    {
                        [self saveCCFramesRectForAnimation:animName];
                    }
                }
            }
		}
	}
	
	for(NSDictionary* jointDict in lhJoints)
	{
		b2Joint* boxJoint = [self b2JointFromDictionary:jointDict world:world];
		
		if(nil != boxJoint){
			[ccJointsInScene setObject:[NSValue valueWithPointer:boxJoint] 
								forKey:[jointDict objectForKey:@"UniqueName"]];	
		}
	}	
    
    for(NSDictionary* parallaxDict in lhParallax)
    {
        NSMutableDictionary* nodeInfo = [[[NSMutableDictionary alloc] init] autorelease];
        CCParallaxNode* node = [self parallaxNodeFromDictionary:parallaxDict layer:cocosLayer saveDict:nodeInfo];
        
        [nodeInfo setObject:[parallaxDict objectForKey:@"ContinuousScrolling"] forKey:@"ContinuousScrolling"];
        [nodeInfo setObject:[parallaxDict objectForKey:@"Speed"] forKey:@"Speed"];
        [nodeInfo setObject:[parallaxDict objectForKey:@"Direction"] forKey:@"Direction"];
        
        if(nil != node)
        {
            [nodeInfo setObject:node forKey:@"Node"];
        }

        [ccParallaxInScene setObject:nodeInfo forKey:[parallaxDict objectForKey:@"UniqueName"]];
    }
}
////////////////////////////////////////////////////////////////////////////////
-(CGPoint) pointOnCurve:(CGPoint) p1 p2:(CGPoint)p2 p3:(CGPoint)p3 p4:(CGPoint)p4 t:(float)t
{
	float var1, var2, var3;
    CGPoint vPoint = {0.0f, 0.0f};
    
    var1 = 1 - t;
    var2 = var1 * var1 * var1;
    var3 = t * t * t;
    vPoint.x = var2*p1.x + 3*t*var1*var1*p2.x + 3*t*t*var1*p3.x + var3*p4.x;
    vPoint.y = var2*p1.y + 3*t*var1*var1*p2.y + 3*t*t*var1*p3.y + var3*p4.y;
    return(vPoint);				
}
////////////////////////////////////////////////////////////////////////////////
-(CCFiniteTimeAction *) getActionSequence: (NSArray *) actions
{
    CCFiniteTimeAction *seq = nil;
    for (CCFiniteTimeAction *anAction in actions)
    {
        if (!seq){
            seq = anAction;
        }else{
            seq = [CCSequence actionOne:seq two:anAction];
        }
    }
    return seq;
}
////////////////////////////////////////////////////////////////////////////////
-(void) createBezierPath:(NSDictionary*)bezierDict
{
    int MAX_STEPS = 25;
    CGSize winSize = [[CCDirector sharedDirector] winSize];
    
    CGPoint conv = {1.0f, 1.0f};
    if(convertLevel)
        conv = convertRatio;

    NSMutableArray* pointsInPath = [[[NSMutableArray alloc] init] autorelease];
    NSString* uniqueName = [bezierDict objectForKey:@"UniqueName"];
    NSArray* curvesInShape = [bezierDict objectForKey:@"Curves"];
    bool isSimpleLine = [[bezierDict objectForKey:@"IsSimpleLine"] boolValue];
    
    bool first = true;
    for(NSDictionary* curvDict in curvesInShape)
    {
        CGPoint endCtrlPt   = LHPointFromString([curvDict objectForKey:@"EndControlPoint"]);
        CGPoint startCtrlPt = LHPointFromString([curvDict objectForKey:@"StartControlPoint"]);
        CGPoint endPt       = LHPointFromString([curvDict objectForKey:@"EndPoint"]);
        CGPoint startPt     = LHPointFromString([curvDict objectForKey:@"StartPoint"]);
        
        if(!isSimpleLine)
        {
            for(float t = 0; t <= (1 + (1.0f / MAX_STEPS)); t += 1.0f / MAX_STEPS)
            {
                CGPoint vPoint = [self pointOnCurve:startPt
                                                 p2:startCtrlPt
                                                 p3:endCtrlPt
                                                 p4:endPt
                                                  t:t];
    
                [pointsInPath addObject:LHValueWithPoint(LHMakePoint(vPoint.x*conv.x, winSize.height - vPoint.y*conv.y))];
            }
        }
        else
        {
            if(first)
            {
                [pointsInPath addObject:LHValueWithPoint(LHMakePoint(startPt.x*conv.x, winSize.height - startPt.y*conv.y))];            
                
                first = false;
            }
            [pointsInPath addObject:LHValueWithPoint(LHMakePoint(endPt.x*conv.x, winSize.height - endPt.y*conv.y))];            
        }
    }

    [ccBezierPathsInScene setObject:pointsInPath forKey:uniqueName];
    
}

-(void) updateContinuousParallaxScrolling:(ccTime) dt
{
    CGPoint conv = {1.0f, 1.0f};
    
    if(convertLevel)
        conv = convertRatio;
    
    
    NSArray* parallaxKeys = [ccParallaxInScene allKeys];
    
    for(NSString* key in parallaxKeys)
    {
        NSMutableDictionary* dic =  [ccParallaxInScene objectForKey:key];
        if(dic != nil)
        {
            if([[dic objectForKey:@"ContinuousScrolling"] boolValue])
            {
                int direction = [[dic objectForKey:@"Direction"] intValue]; //0 --> 1 ---> 2 down 3 up
                float speed = [[dic objectForKey:@"Speed"] floatValue];
                
                CGSize winSize = [[CCDirector sharedDirector] winSize];
                
                NSArray* sprInNode = [dic objectForKey:@"SpritesInNode"];
                
                for(NSMutableDictionary* sprInfo in sprInNode)
                {
                    
                    CCSprite* spr = [sprInfo objectForKey:@"CocosSprite"];
                    float ratioX = [[sprInfo objectForKey:@"RatioX"] floatValue];
                    float ratioY = [[sprInfo objectForKey:@"RatioY"] floatValue];
                    
                    CGPoint initialPosition = LHPointFromValue([sprInfo objectForKey:@"InitialPosition"]);
                    CGPoint sprPos = spr.position;
                    
                    switch (direction)
                    {
                        case 0: //left to right
                        {
                            sprPos.x += ratioX*speed*conv.x;
                            sprPos.y += ratioY*speed*conv.y;
                            
                            
                            if(0 < initialPosition.x)
                            {
                                if(spr.position.x > winSize.width + initialPosition.x)
                                {
                                    sprPos.x = 0 - winSize.width + initialPosition.x;
                                }
                            }
                            else
                            {
                                if(spr.position.x > winSize.width + (winSize.width + initialPosition.x))
                                {
                                    sprPos.x = initialPosition.x;
                                }
                            }
                            
                            spr.position = sprPos;
                            
                        }   
                            break;
                            
                        case 1: //right to left
                        {
                            
                            sprPos.x -= ratioX*speed*conv.x;
                            sprPos.y -= ratioY*speed*conv.y;
                            
                            if(winSize.width > initialPosition.x)
                            {
                                if(spr.position.x < -winSize.width + initialPosition.x)
                                {
                                    sprPos.x = winSize.width + initialPosition.x;
                                }
                            }
                            else
                            {
                                if(spr.position.x < -winSize.width + (initialPosition.x - winSize.width))
                                {
                                    sprPos.x = initialPosition.x;
                                }
                            }
                            
                            spr.position = sprPos;
                        }
                            break;
                            
                        case 2: //up to down
                        {
                            
                            sprPos.x -= ratioX*speed*conv.x;
                            sprPos.y -= ratioY*speed*conv.y;
                            
                            if(initialPosition.y < winSize.height) 
                            {
                                if( -winSize.height + initialPosition.y > spr.position.y)
                                {
                                    sprPos.y = winSize.height + initialPosition.y;
                                }
                            }
                            else
                            {
                                if(spr.position.y < -winSize.height + (initialPosition.y - winSize.height))
                                {
                                    sprPos.y = initialPosition.y;
                                }
                            }
                            
                            spr.position = sprPos;
                        }
                            break;
                            
                            
                        case 3: //down to up
                        {
                            
                            sprPos.x += ratioX*speed*conv.x;
                            sprPos.y += ratioY*speed*conv.y;
                            
                            if(initialPosition.y > 0) 
                            {
                                if(winSize.height + initialPosition.y < spr.position.y)
                                {
                                    sprPos.y = 0 - winSize.height + initialPosition.y;
                                }
                            }
                            else
                            {
                                if(spr.position.y > winSize.height + (winSize.height + initialPosition.y))
                                {
                                    sprPos.y = initialPosition.y;
                                }
                            }
                            
                            spr.position = sprPos;
                        }
                            break;
                            
                    }
                    
                }
            }  
        }
    }
}

-(void) releaseAllPathsMovement
{
    for(NSValue* value in moveOnPathInfo)
    {
        lhPathInfo* info = (lhPathInfo*)[value pointerValue];
        delete info;
    }
    
    [moveOnPathInfo removeAllObjects];
}
-(void) updateMovingOnPath:(ccTime) dt
{
    NSMutableArray* toBeRemoved = [[NSMutableArray alloc] init];
    for(NSValue* value in moveOnPathInfo)
    {
        if(value == nil)
            return;
        
        lhPathInfo* info = (lhPathInfo*)[value pointerValue];
        
        if(0 != info)
        {
            if(info->ccSprite == nil)
                return;
            
            if(info->paused) 
            {
                break;
            }
            
            NSArray* points = [ccBezierPathsInScene objectForKey:info->pathUniqueName];
            
            if(nil == points)
                return;
            
            if(info->needsReversed == true)
            {
                info->reversed = true;
                info->needsReversed = false;
                info->currentPoint = [points count] - 1;
                info->elapsed = 0;
            }
            
            NSValue* ptVal = [points objectAtIndex:info->currentPoint];
            CGPoint startPosition = LHPointFromValue(ptVal);
            
            CGPoint endPosition = startPosition;
            if(!info->reversed)
            {
                if((info->currentPoint + 1) < (int)[points count])
                {
                    NSValue* val = [points objectAtIndex:info->currentPoint + 1];
                    endPosition = LHPointFromValue(val);                
                }
            }
            else
            {
                if((info->currentPoint - 1) >= 0)
                {
                    NSValue* val = [points objectAtIndex:info->currentPoint - 1];
                    endPosition = LHPointFromValue(val);                
                }                
            }
            
            //XXX if startPos = endPos - call notifier and see if we restart or reverse
            //CGPoint pos = [info->ccSprite position];
            
            CGPoint delta = ccpSub( endPosition, startPosition );
            
            if( info->firstTick)
            {
                info->firstTick = false;
                info->elapsed = 0;
            } else
                info->elapsed += dt;
            
            float t = MIN(1, info->elapsed/info->interval);
            
            
            CGPoint newPos = ccp((startPosition.x + delta.x * t), 
                                 (startPosition.y + delta.y * t));
            
            if(info->ccSprite != nil)
                [info->ccSprite setPosition: newPos];
            
            float dist = ccpDistance([info->ccSprite position], endPosition);
            if(0.001 > dist)
            {
                if(!info->reversed)
                {
                    if(info->currentPoint + 1 < (int)[points count])
                    {
                        info->elapsed = 0;
                        info->currentPoint += 1;     
                    }
                    else
                    {
                        if(pathNotifierId != nil)
                        {
                            [pathNotifierId performSelector:pathNotifierSel 
                                                 withObject:info->ccSprite
                                                 withObject:info->pathUniqueName];	
                        }

                        info->reversed = !info->reversed;
                    }
                }
                else
                {
                    if(info->startPoint == 0)
                    {
                        if(info->isCyclic)
                        {
                            if(info->pathOtherEnd)
                            {
                                info->currentPoint = 0;
                                info->elapsed = 0;
                                info->reversed = false;
                                NSValue* ptVal = [points objectAtIndex:0];
                                [info->ccSprite setPosition:LHPointFromValue(ptVal)];
                            }
                            else
                            {
                                if(info->currentPoint -1 >= 0)
                                {
                                    info->elapsed = 0;
                                    info->currentPoint -=1;
                                }
                                else
                                {
                                    if(pathNotifierId != nil)
                                    {
                                        [pathNotifierId performSelector:pathNotifierSel 
                                                             withObject:info->ccSprite 
                                                             withObject:info->pathUniqueName];	
                                    }
                                    
                                    info->reversed = !info->reversed;
                                }
                            }
                        }
                        else
                        {
                            //REMOVE
                            [ccBezierPathsInScene removeObjectForKey:info->pathUniqueName];
                            delete info;
                            
                            [toBeRemoved addObject:value];
                        }
                    }
                    else
                    {
                        //we are starting from the other end 
                        
                        if(info->isCyclic)
                        {
                            if(info->currentPoint -1 >= 0)
                            {
                                info->elapsed = 0;
                                info->currentPoint -=1;
                            }
                            else
                            {
                                if(pathNotifierId != nil)
                                {
                                    [pathNotifierId performSelector:pathNotifierSel 
                                                         withObject:info->ccSprite 
                                                         withObject:info->pathUniqueName];	
                                }
                                
                                if(info->pathOtherEnd)
                                {
                                    info->currentPoint = [points count] - 1;
                                    info->elapsed = 0;
                                    info->reversed = true;
                                    NSValue* ptVal = [points objectAtIndex:info->currentPoint];
                                    [info->ccSprite setPosition:LHPointFromValue(ptVal)];
                                }
                                else{
                                    info->reversed = !info->reversed;
                                }
                            }
                        }
                        else
                        {
                            if(info->currentPoint -1 >= 0)
                            {
                                info->elapsed = 0;
                                info->currentPoint -=1;
                            }
                            else
                            {
                                if(pathNotifierId != nil)
                                {
                                    [pathNotifierId performSelector:pathNotifierSel 
                                                         withObject:info->ccSprite 
                                                         withObject:info->pathUniqueName];	
                                }

                                [ccBezierPathsInScene removeObjectForKey:info->pathUniqueName];
                                delete info;
                                [toBeRemoved addObject:value];
                                //REMOVE
                            }
                        }
                    }
                    
                }
            }
        }
    }
    
    [moveOnPathInfo removeObjectsInArray:toBeRemoved];
    [toBeRemoved release];
    
    
    if(addSpritesToLayerWasUsed)
        return; //we dont need to update if physic is not used
    
    if(ccSpritesInScene == nil)
        return;
    
    NSArray* keys = [ccSpritesInScene allKeys];
    
    for(NSString* name in keys)
    {
        if(name == nil)
            break;
        
        b2Body* body = (b2Body*)[[ccSpritesInScene objectForKey:name] pointerValue];
		
        if(nil != body)
        {
            CCSprite* curSpr = [LevelHelperLoader spriteForBody:body];
            
            if(b2_dynamicBody != body->GetType()) //we dont update dynamic bodies
            {
                if(curSpr != nil)
                {
                    float angle = [curSpr rotation];
                    CGPoint pos = [curSpr position];//[self  metersToPoints:[c[self inverseConvertedPoint:[curSpr position]];
                    body->SetTransform(b2Vec2(pos.x/LH_PTM_RATIO, pos.y/LH_PTM_RATIO), DEGREES_TO_RADIANS(-angle));
                }
            }
        }
    }
}
-(void) update:(ccTime) dt
{
    [self updateContinuousParallaxScrolling:dt];
    
    [self updateMovingOnPath:dt];
    ///////////////////////////////////
}
////////////////////////////////////////////////////////////////////////////////

-(void) moveSpriteWithUniqueName:(NSString*)sprName onPathWithUniqueName:(NSString*)uniqueName 
                           speed:(float)pathSpeed 
                 startAtEndPoint:(bool)startAtEndPoint
                        isCyclic:(bool)isCyclic
               restartAtOtherEnd:(bool)restartOtherEnd
{
    CCSprite* spr = [self spriteWithUniqueName:sprName];
    
    [self moveSprite:spr onPathWithUniqueName:uniqueName speed:pathSpeed startAtEndPoint:startAtEndPoint isCyclic:isCyclic restartAtOtherEnd:restartOtherEnd];
}

-(void) moveSprite:(CCSprite *)ccsprite 
                    onPathWithUniqueName:(NSString*)uniqueName 
            speed:(float)pathSpeed 
        startAtEndPoint:(bool)startAtEndPoint
          isCyclic:(bool)isCyclic
 restartAtOtherEnd:(bool)restartOtherEnd
{
    if(nil == ccsprite || uniqueName == nil)
        return;
        
    NSArray* points = [ccBezierPathsInScene objectForKey:uniqueName];
    
    if(nil == points)
    {
        NSLog(@"LevelHelper Warning: No path has been found with unique name: \"%@\"", uniqueName);
        return;
    }
    lhPathInfo* info = new lhPathInfo;
    
    //lets see the time interval between points 
    float interval = pathSpeed/([points count]);
    
    info->pathUniqueName = uniqueName;
    info->currentPoint = 0;
    info->isCyclic = isCyclic;
    info->interval = interval;
    info->startPoint = (int)startAtEndPoint;
    info->needsReversed = startAtEndPoint;
    info->ccSprite = ccsprite;
    info->pathOtherEnd = restartOtherEnd;
    info->firstTick = true;
    info->reversed = false;
    info->paused = false;
    
    [moveOnPathInfo addObject:[NSValue valueWithPointer:info]];    
}

-(void) pausePathMovement:(bool)pauseStatus ofSpriteWithUniqueName:(NSString*)sprName
{
    CCSprite* spr = [self spriteWithUniqueName:sprName];
    
    [self pausePathMovement:pauseStatus ofSprite:spr];    
}

-(void) pausePathMovement:(bool)pauseStatus ofSprite:(CCSprite*)ccsprite
{
    if(ccsprite == nil)
        return;
    
    for(NSValue* value in moveOnPathInfo)
    {
        lhPathInfo* info = (lhPathInfo*)[value pointerValue];
        
        if([info->ccSprite isEqual:ccsprite])
        {
            info->paused = pauseStatus;
        }
    }
}

-(void) createPathOnSprite:(CCSprite*)ccsprite 
            withProperties:(NSDictionary*)spriteProp 

{
    
    if(nil == ccsprite || nil == spriteProp)
        return;
    
    //   NSLog(@"createPathOnSprite");
    NSString* uniqueName = [spriteProp objectForKey:@"PathName"];
    bool isCyclic = [[spriteProp objectForKey:@"PathIsCyclic"] boolValue];
    float pathSpeed = [[spriteProp objectForKey:@"PathSpeed"] floatValue];
    int startPoint = [[spriteProp objectForKey:@"PathStartPoint"] intValue]; //0 is first 1 is end
    bool pathOtherEnd = [[spriteProp objectForKey:@"PathOtherEnd"] boolValue]; //false means will restart where it finishes
    
    
    [self moveSprite:ccsprite onPathWithUniqueName:uniqueName 
               speed:pathSpeed 
     startAtEndPoint:startPoint 
            isCyclic:isCyclic 
   restartAtOtherEnd:pathOtherEnd];
}

////////////////////////////////////////////////////////////////////////////////
-(void) registerNotifierOnPathEndPoints:(id)obj selector:(SEL)sel
{
    pathNotifierId = obj;
    pathNotifierSel = sel;
}
////////////////////////////////////////////////////////////////////////////////
-(void) registerNotifierOnAnimationEnds:(id)obj selector:(SEL)sel
{
    animNotifierId = obj;
    animNotifierSel = sel;
}
////////////////////////////////////////////////////////////////////////////////
-(void) enableNotifOnLoopForeverAnimations
{
    notifOnLoopForeverAnim = true;
}
////////////////////////////////////////////////////////////////////////////////
-(void)saveCCFramesRectForAnimation:(NSString*)uniqueName
{
    if([ccFramesForAnimation objectForKey:uniqueName] != nil)
        return;
    
    for(NSDictionary* anim in lhAnims)
    {
        NSString* uniqueAnimName = [anim objectForKey:@"UniqueName"];
        
        if([uniqueAnimName isEqualToString:uniqueName])
        {
            NSArray* framesInfo = [anim objectForKey:@"Frames"];

            NSMutableArray *ccframes = [NSMutableArray array];
    
            for(NSDictionary* frm in framesInfo)
            {
                NSValue* frame = LHValueWithRect(LHRectFromString([frm objectForKey:@"FrameRect"]));
                [ccframes addObject:frame];      
            }
            
            [ccFramesForAnimation setObject:ccframes forKey:uniqueAnimName];
        }
    }
}
////////////////////////////////////////////////////////////////////////////////
-(CCFiniteTimeAction*) createAnimOnSprite:(CCSprite*)ccsprite
                               uniqueName:(NSString*)uniqueName
                                   frames:(NSArray*)framesInfo
                                     loop:(bool)loop
                              repetitions:(int)repetitions
                                    speed:(float)animSpeed
{
    if(uniqueName == nil || framesInfo == nil || [framesInfo count] == 0)
        return nil;
    
    NSMutableArray *ccframes = [NSMutableArray array];
    
    for(NSDictionary* frm in framesInfo)
    {
        CGRect rect = LHRectFromString([frm objectForKey:@"FrameRect"]);
        
        if([self isIpad])
        {
            rect.origin.x *=2.0f;
            rect.origin.y *=2.0f;
            rect.size.width *=2.0f;
            rect.size.height *=2.0f;
        }
        
        CCSpriteFrame* frame = [CCSpriteFrame frameWithTexture:[ccsprite texture] 
                                                          rect:rect];
        [ccframes addObject:frame];      
    }
    CCAnimation *anim = [CCAnimation animationWithFrames:ccframes delay:animSpeed];
    
    CCFiniteTimeAction *seq;
    if(!loop)
    {
        id animAct = [CCRepeat actionWithAction:[CCAnimate actionWithAnimation:anim 
                                                          restoreOriginalFrame:NO] 
                                          times:repetitions];
        
        if(nil != animNotifierId && nil != animNotifierSel)
        {
            id actionRestart = [CCCallFuncND actionWithTarget:animNotifierId 
                                                     selector:animNotifierSel 
                                                         data:uniqueName];
            seq = [CCSequence actionOne:animAct two:actionRestart];
        }
        else
        {
            seq = [CCSequence actions:animAct, nil];
        }
    }
    else
    {
        if(notifOnLoopForeverAnim && nil != animNotifierId && nil != animNotifierSel)
        {
            id actionRestart = [CCCallFuncND actionWithTarget:animNotifierId selector:animNotifierSel data:uniqueName];
            id animAct = [CCSequence actionOne:[CCAnimate actionWithAnimation:anim 
                                                         restoreOriginalFrame:NO] two:actionRestart];
            
            seq = [CCRepeatForever actionWithAction:animAct];
        }
        else
        {
            seq = [CCRepeatForever actionWithAction:[CCAnimate actionWithAnimation:anim 
                                                              restoreOriginalFrame:NO]];
        }
    }
    
    [seq setTag:LH_ANIM_ACTION_TAG];
    return seq;
}
////////////////////////////////////////////////////////////////////////////////
-(void) createAnimOnSprite:(CCSprite*)ccsprite withProperties:(NSDictionary*)spriteProp
{
    if(nil == ccsprite || nil == spriteProp)
        return;
    
    NSString* uniqueName = [spriteProp objectForKey:@"AnimName"];
    bool loop = [[spriteProp objectForKey:@"AnimLoop"] boolValue];
    float animSpeed = [[spriteProp objectForKey:@"AnimSpeed"] floatValue];
    int repetitions = [[spriteProp objectForKey:@"AnimRepetitions"] intValue];
   
    for(NSDictionary* anim in lhAnims)
    {
        NSString* uniqueAnimName = [anim objectForKey:@"UniqueName"];
        
        if([uniqueAnimName isEqualToString:uniqueName])
        {
            NSArray* framesInfo = [anim objectForKey:@"Frames"];
        
            CCFiniteTimeAction *seq = [self createAnimOnSprite:(CCSprite*)ccsprite
                                                    uniqueName:uniqueAnimName
                                                        frames:framesInfo
                                                          loop:loop
                                                   repetitions:repetitions
                                                         speed:animSpeed];
            
            if(seq != nil)
            {
                NSMutableDictionary* spriteUserData = (NSMutableDictionary*)[ccsprite userData];
                [spriteUserData setObject:uniqueAnimName forKey:@"AnimName"];
                
                [ccsprite runAction:seq];    
            }
        }
    }
}
////////////////////////////////////////////////////////////////////////////////
-(void) startAnimationWithUniqueName:(NSString *)animName onSprite:(CCSprite*)ccsprite
{
    for(NSDictionary* anim in lhAnims)
    {
        NSString* uniqueAnimName = [anim objectForKey:@"UniqueName"];
        if([animName isEqualToString:uniqueAnimName])
        {
            bool loop = [[anim objectForKey:@"LoopForever"] boolValue];
            float animSpeed = [[anim objectForKey:@"Speed"] floatValue];
            int repetitions = [[anim objectForKey:@"Repetitions"] intValue];
            
            NSArray* framesInfo = [anim objectForKey:@"Frames"];
            
            CCFiniteTimeAction *seq = [self createAnimOnSprite:ccsprite
                                                    uniqueName:uniqueAnimName
                                                        frames:framesInfo
                                                          loop:loop
                                                   repetitions:repetitions
                                                         speed:animSpeed];
            
            if(seq != nil)
            {
                NSMutableDictionary* spriteUserData = (NSMutableDictionary*)[ccsprite userData];
                [spriteUserData setObject:uniqueAnimName forKey:@"AnimName"];

                [ccsprite runAction:seq];    
            }
        }
    }        
}
////////////////////////////////////////////////////////////////////////////////
-(void) startAnimationWithUniqueName:(NSString*)animName onSpriteWithUniqueName:(NSString*)sprName
{
    [self stopAnimationWithUniqueName:animName onSpriteWithUniqueName:sprName];
    
    CCSprite* ccsprite = [self spriteWithUniqueName:sprName];
    
    [self startAnimationWithUniqueName:animName onSprite:ccsprite];
}
////////////////////////////////////////////////////////////////////////////////
-(void) stopAnimationWithUniqueName:(NSString*)animName onSprite:(CCSprite*)ccsprite
{
    if(nil != ccsprite)
    {
        [ccsprite stopActionByTag:LH_ANIM_ACTION_TAG];
    }    
}
////////////////////////////////////////////////////////////////////////////////
-(void) stopAnimationWithUniqueName:(NSString*)animName onSpriteWithUniqueName:(NSString*)sprName
{
    CCSprite* ccsprite = [self spriteWithUniqueName:sprName];

    [self stopAnimationWithUniqueName:animName onSprite:ccsprite];
}
////////////////////////////////////////////////////////////////////////////////
-(void) nextFrameForSprite:(CCSprite*)ccsprite
{
    [self nextFrameForSprite:ccsprite repeat:false];
}
-(void) nextFrameForSprite:(CCSprite*)ccsprite repeat:(bool)repeat
{
    if(ccsprite == nil)
        return;
    
    NSMutableDictionary* sprInfo = (NSMutableDictionary*)[ccsprite userData];
    
    if(sprInfo == nil)
        return;
    
    NSArray* frames = [ccFramesForAnimation objectForKey:[sprInfo objectForKey:@"AnimName"]];
    
    if(frames == nil)
        return;
    
    int curFrame = [[sprInfo objectForKey:@"CurrentFrame"] intValue];
    
    curFrame +=1;
        
    if(curFrame == (int)[frames count] -1)
    {
        if(nil != animNotifierId)
        {
            [animNotifierId performSelector:animNotifierSel 
                                 withObject:ccsprite
                                 withObject:[sprInfo objectForKey:@"AnimName"]];	
        }
    }
    
    if(repeat && curFrame >= (int)[frames count])
    {
        curFrame = 0;
    }
    
    if(curFrame >= 0 && curFrame < (int)[frames count])
    {
        [sprInfo setObject:[NSNumber numberWithInt:curFrame] forKey:@"CurrentFrame"];
        
        CGRect frmRect = LHRectFromValue([frames objectAtIndex:curFrame]);
        [ccsprite setTextureRect:frmRect];
    }    
}
////////////////////////////////////////////////////////////////////////////////
-(void) nextFrameForSpriteWithUniqueName:(NSString*)sprName
{
    CCSprite* spr = [self spriteWithUniqueName:sprName];
    
    [self nextFrameForSprite:spr repeat:NO];
}
-(void) nextFrameForSpriteWithUniqueName:(NSString*)sprName repeat:(bool)repeat
{
    CCSprite* spr = [self spriteWithUniqueName:sprName];
    
    [self nextFrameForSprite:spr repeat:repeat];    
}
////////////////////////////////////////////////////////////////////////////////
-(void) prevFrameForSprite:(CCSprite*)spr
{
    [self prevFrameForSprite:spr repeat:NO];
}
-(void) prevFrameForSprite:(CCSprite*)spr repeat:(bool)repeat
{
    if(spr == nil)
        return;
    
    NSMutableDictionary* sprInfo = (NSMutableDictionary*)[spr userData];
    
    if(sprInfo == nil)
        return;
    
    NSArray* frames = [ccFramesForAnimation objectForKey:[sprInfo objectForKey:@"AnimName"]];
    
    if(frames == nil)
        return;
    
    int curFrame = [[sprInfo objectForKey:@"CurrentFrame"] intValue];
    
    curFrame -=1;
    
    if(repeat && curFrame < 0)
    {
        curFrame = [frames count] - 1;
        
        if(nil != animNotifierId)
        {
            [animNotifierId performSelector:animNotifierSel 
                                 withObject:spr
                                 withObject:[sprInfo objectForKey:@"AnimName"]];	
        }
    }
    
    if(curFrame >= 0 && curFrame < (int)[frames count])
    {
        [sprInfo setObject:[NSNumber numberWithInt:curFrame] forKey:@"CurrentFrame"];
        
        CGRect frmRect = LHRectFromValue([frames objectAtIndex:curFrame]);
        [spr setTextureRect:frmRect];
    }        
}

////////////////////////////////////////////////////////////////////////////////
-(void) prevFrameForSpriteWithUniqueName:(NSString*)sprName
{
    CCSprite* spr = [self spriteWithUniqueName:sprName];
    [self prevFrameForSprite:spr repeat:NO];
}
-(void) prevFrameForSpriteWithUniqueName:(NSString*)sprName repeat:(bool)repeat
{
    CCSprite* spr = [self spriteWithUniqueName:sprName];
    [self prevFrameForSprite:spr repeat:YES];    
}

-(int) numberOfFrameForBody:(b2Body*)body
{
    NSString* animName = [LevelHelperLoader animationNameOnBody:body];
    
    if(animName == nil)
        return -1;
    
    NSArray* frames = [ccFramesForAnimation objectForKey:animName];
    
    if(frames == nil)
        return -1;
    
    return [frames count];
}
-(int) numberOfFrameForSprite:(CCSprite*)sprite
{
    NSString* animName = [LevelHelperLoader animationNameOnSprite:sprite];
    
    if(animName == nil)
        return -1;
    
    NSArray* frames = [ccFramesForAnimation objectForKey:animName];
    
    if(frames == nil)
        return -1;
    
    return [frames count];   
}

-(bool) isBodyAtLastFrame:(b2Body*)body
{
    NSString* animName = [LevelHelperLoader animationNameOnBody:body];
    
    if(animName == nil)
        return false;
    
    NSArray* frames = [ccFramesForAnimation objectForKey:animName];
    
    if(frames == nil)
        return false;
    
    int curFrame = [LevelHelperLoader currentFrameOnBody:body];
    
    if(curFrame == -1)
        return false;
    
    if(curFrame == (int)[frames count] -1)
        return true;
    
    return false;
}
-(bool) isSpriteAtLastFrame:(CCSprite*)sprite
{
    NSString* animName = [LevelHelperLoader animationNameOnSprite:sprite];
    
    if(animName == nil)
        return false;
    
    NSArray* frames = [ccFramesForAnimation objectForKey:animName];
    
    if(frames == nil)
        return false;
    
    int curFrame = [LevelHelperLoader currentFrameOnSprite:sprite];
    
    if(curFrame == -1)
        return false;
    
    if(curFrame == (int)[frames count] -1)
        return true;
    
    return false;    
}
////////////////////////////////////////////////////////////////////////////////
-(b2Body*) b2BezierBodyFromDictionary:(NSDictionary*)bezierDict world:(b2World*)world
{
    b2BodyDef bodyDef;	
	
	bodyDef.type = b2_staticBody;
	bodyDef.position.Set(0.0f, 0.0f);
	bodyDef.angle = DEGREES_TO_RADIANS(0.0f);
	
    //CREATE DUMMY CCSPRITE AND SETS ITS VISIBILITY FALSE
    CCSprite* spr = [[CCSprite alloc] init];
    [spr setTag:[[bezierDict objectForKey:@"Tag"] intValue]]; 
    [spr setVisible:false];

    NSMutableDictionary* spriteUserData = [[NSMutableDictionary alloc] init];
    [spriteUserData setObject:[bezierDict objectForKey:@"UniqueName"] forKey:@"UniqueName"];
    [spr setUserData:spriteUserData];
    
    bodyDef.userData = spr;
        
	b2Body* body = world->CreateBody(&bodyDef);
	
    bool isSimpleLine = [[bezierDict objectForKey:@"IsSimpleLine"] boolValue];
    
    NSArray* curvesInShape = [bezierDict objectForKey:@"Curves"];
    
    int MAX_STEPS = 25;
    
    CGPoint wbConv = {1.0f, 1.0f};
    
    if(convertLevel)
        wbConv = convertRatio;
        
    CGSize winSize = [[CCDirector sharedDirector] winSize];
	
    for(NSDictionary* curvDict in curvesInShape)
    {
        CGPoint endCtrlPt   = LHPointFromString([curvDict objectForKey:@"EndControlPoint"]);
        CGPoint startCtrlPt = LHPointFromString([curvDict objectForKey:@"StartControlPoint"]);
        CGPoint endPt       = LHPointFromString([curvDict objectForKey:@"EndPoint"]);
        CGPoint startPt     = LHPointFromString([curvDict objectForKey:@"StartPoint"]);
          
        if(!isSimpleLine)
        {
            CGPoint prevPoint;
            bool firstPt = true;
            for(float t = 0; t <= (1 + (1.0f / MAX_STEPS)); t += 1.0f / MAX_STEPS)
            {
                CGPoint vPoint = [self pointOnCurve:startPt
                                                 p2:startCtrlPt
                                                 p3:endCtrlPt
                                                 p4:endPt
                                                  t:t];
            
                if(!firstPt)
                {
                    b2Vec2 *verts = new b2Vec2[2];
                    b2PolygonShape shape;
                
                    verts[0] = b2Vec2(prevPoint.x*wbConv.x/LH_PTM_RATIO, 
                                      (winSize.height - prevPoint.y*wbConv.y)/LH_PTM_RATIO);
                    verts[1] = b2Vec2(vPoint.x*wbConv.x/LH_PTM_RATIO, 
                                      (winSize.height - vPoint.y*wbConv.y)/LH_PTM_RATIO);
                
                    shape.Set(verts, 2);		
                    b2FixtureDef fixture;
                    [self setFixtureDefPropertiesFromDictionary:bezierDict fixture:&fixture];
                    fixture.shape = &shape;
                    body->CreateFixture(&fixture);
                    delete verts;
                }
                
                prevPoint = vPoint;
                firstPt = false;
            
            }
        }
        else
        {
            b2Vec2 *verts = new b2Vec2[2];
            b2PolygonShape shape;

            verts[0] = b2Vec2(startPt.x*wbConv.x/LH_PTM_RATIO, 
                              (winSize.height - startPt.y*wbConv.y)/LH_PTM_RATIO);
            verts[1] = b2Vec2(endPt.x*wbConv.x/LH_PTM_RATIO, 
                              (winSize.height - endPt.y*wbConv.y)/LH_PTM_RATIO);
            
            shape.Set(verts, 2);		
            b2FixtureDef fixture;
            [self setFixtureDefPropertiesFromDictionary:bezierDict fixture:&fixture];
            fixture.shape = &shape;
            body->CreateFixture(&fixture);
            delete verts;

        }
    }
    
    [self setCustomAttributesForBezierBodies:bezierDict
                                      sprite:spr body:body];
    
	return body;
}
////////////////////////////////////////////////////////////////////////////////
-(CCParallaxNode*) paralaxNodeWithUniqueName:(NSString*)uniqueName
{
    NSMutableDictionary* dic =  [ccParallaxInScene objectForKey:uniqueName];
    if(dic != nil)
        return [dic objectForKey:@"Node"];
    
    return nil;
}
////////////////////////////////////////////////////////////////////////////////
-(NSArray*) spritesInParallaxNodeWithUniqueName:(NSString*)uniqueName
{
    NSMutableDictionary* dic =  [ccParallaxInScene objectForKey:uniqueName];
    if(dic != nil)
        return [dic objectForKey:@"SpritesInNode"];
    
    return nil;    
}

-(NSDictionary*) generalPropDictionaryForSpriteWithUniqueName:(NSString*)name
{
    
    for(NSDictionary* dictionary in lhSprites)
    {
        NSDictionary* spriteProp = [dictionary objectForKey:@"GeneralProperties"];
        
        if([[spriteProp objectForKey:@"UniqueName"] isEqualToString:name])
        {
            return spriteProp;
        }
    }
    return nil;
}
////////////////////////////////////////////////////////////////////////////////
-(CCParallaxNode*) parallaxNodeFromDictionary:(NSDictionary*)parallaxDict layer:(CCLayer*)layer saveDict:(NSMutableDictionary*)saveInfo
{
    bool isContinuous = [[parallaxDict objectForKey:@"ContinuousScrolling"] boolValue];
    
    CCParallaxNode * node = nil;
    if(!isContinuous)
    {
            node = [CCParallaxNode node];
    }
    if(cocosLayer != nil && node != nil)
    {
        int z = [[parallaxDict objectForKey:@"ZOrder"] intValue];
        [cocosLayer addChild:node z:z];
    }
    
    NSArray* spritesInfo = [parallaxDict objectForKey:@"Sprites"];
    
    NSMutableArray* spritesInNode = [[[NSMutableArray alloc] init] autorelease];
    for(NSDictionary* sprInf in spritesInfo)
    {
        float ratioX = [[sprInf objectForKey:@"RatioX"] floatValue];
        float ratioY = [[sprInf objectForKey:@"RatioY"] floatValue];
        NSString* sprName = [sprInf objectForKey:@"SpriteName"];
        
        NSMutableDictionary* nodeSprInfo = [[[NSMutableDictionary alloc] init] autorelease];
        
        [nodeSprInfo setObject:[NSNumber numberWithFloat:ratioX] forKey:@"RatioX"];
        [nodeSprInfo setObject:[NSNumber numberWithFloat:ratioY] forKey:@"RatioY"];
        
        
        CCSprite* spr = nil;
        if(!isContinuous)
        {
            spr = [self newSpriteWithUniqueName:sprName cocos2dLayer:nil];
        }
        else
        {
            spr = [self newSpriteWithUniqueName:sprName];// cocos2dLayer:cocosLayer];
        }
        
              
        if(spr != nil)
        {
            [nodeSprInfo setObject:LHValueWithPoint(spr.position) forKey:@"InitialPosition"];
            [nodeSprInfo setObject:spr forKey:@"CocosSprite"];
            [spritesInNode addObject:nodeSprInfo];
            
            NSDictionary* prop = [self generalPropDictionaryForSpriteWithUniqueName:sprName];
            int z = [[prop objectForKey:@"ZOrder"] intValue];
            
            if(nil != node)
            {
                [node addChild:spr z:z parallaxRatio:ccp(ratioX, ratioY) positionOffset:[spr position]];
            }
        }
    }

    [saveInfo setObject:spritesInNode forKey:@"SpritesInNode"];
    
    return node;
}
////////////////////////////////////////////////////////////////////////////////
-(bool) isGravityZero
{
    if(gravity.x == 0 && gravity.y == 0)
        return true;
    
    return false;
}
-(void) createGravity:(b2World*)world
{
    world->SetGravity(b2Vec2(gravity.x, gravity.y));
}
-(bool) hasWorldBoundaries
{
	if(wb == nil)
	{
		return false;
	}
    
    CGRect rect = LHRectFromString([wb objectForKey:@"WBRect"]);    
    if(rect.size.width == 0 || rect.size.height == 0)
        return false;
	
	return true;
}
////////////////////////////////////////////////////////////////////////////////
//STILL DECIDING TO INCLUDE THIS OR NOT - IF I DO - I BREAK COMPATIBILITY 
//BECAUSE I WILL NEED TO RETURN ARRAY OF BODIES (4)
-(b2Body*) createWorldBoundaries:(b2World*)_world 
                          topTag:(int)t 
                         leftTag:(int)l 
                       bottomTag:(int)b 
                        rightTag:(int)r
{
    if(![self hasWorldBoundaries])
    {
        NSLog(@"LevelHelper WARNING - Please create world boundaries in LevelHelper in order to call method \"createWorldBoundaries\"");
        return 0;
    }	
    
    CGPoint wbConv = {1.0f, 1.0f};
    
    if(convertLevel)// && convertPhysic)
        wbConv = convertRatio;
    
    
    b2BodyDef bodyDef;	
	
	bodyDef.type = b2_staticBody;
	bodyDef.position.Set(0.0f, 0.0f);
    wbBody = _world->CreateBody(&bodyDef);
	
    
    CGRect rect = LHRectFromString([wb objectForKey:@"WBRect"]);    
    CGSize winSize = [[CCDirector sharedDirector] winSize];
        
    {//TOP
        b2Vec2 *verts = new b2Vec2[2];
        
        b2PolygonShape shape;
        
        verts[0] = b2Vec2(rect.origin.x/LH_PTM_RATIO*wbConv.x,
                          (winSize.height - rect.origin.y*wbConv.y)/LH_PTM_RATIO);
        
        verts[1] = b2Vec2((rect.origin.x + rect.size.width)*wbConv.x/LH_PTM_RATIO, 
                          (winSize.height - rect.origin.y*wbConv.y)/LH_PTM_RATIO);
        
        
        shape.Set(verts, 2);		
        b2FixtureDef fixture;
        [self setFixtureDefPropertiesFromDictionary:wb fixture:&fixture];
        fixture.shape = &shape;
        fixture.isSensor = false;
        wbBody->CreateFixture(&fixture);
        delete verts;
    }

    {//LEFT
        b2Vec2 *verts = new b2Vec2[2];
        
        b2PolygonShape shape;
        
        verts[0] = b2Vec2(rect.origin.x*wbConv.x/LH_PTM_RATIO,
                          (winSize.height - rect.origin.y*wbConv.y)/LH_PTM_RATIO);
        
        verts[1] = b2Vec2((rect.origin.x*wbConv.x)/LH_PTM_RATIO, 
                          (winSize.height - (rect.origin.y + rect.size.height)*wbConv.y)/LH_PTM_RATIO);
        
        
        shape.Set(verts, 2);		
        b2FixtureDef fixture;
        [self setFixtureDefPropertiesFromDictionary:wb fixture:&fixture];
        fixture.shape = &shape;
        wbBody->CreateFixture(&fixture);
        delete verts;
    }

    {//RIGHT
        b2Vec2 *verts = new b2Vec2[2];
        
        b2PolygonShape shape;
        
        verts[0] = b2Vec2((rect.origin.x + rect.size.width)*wbConv.x/LH_PTM_RATIO,
                          (winSize.height - rect.origin.y*wbConv.y)/LH_PTM_RATIO);
        
        verts[1] = b2Vec2((rect.origin.x+ rect.size.width)*wbConv.x/LH_PTM_RATIO, 
                          (winSize.height - (rect.origin.y + rect.size.height)*wbConv.y)/LH_PTM_RATIO);
        
        
        shape.Set(verts, 2);		
        b2FixtureDef fixture;
        [self setFixtureDefPropertiesFromDictionary:wb fixture:&fixture];
        fixture.shape = &shape;
        wbBody->CreateFixture(&fixture);
        delete verts;
    }

    {//BOTTOM
        b2Vec2 *verts = new b2Vec2[2];
        
        b2PolygonShape shape;
        
        verts[0] = b2Vec2(rect.origin.x*wbConv.x/LH_PTM_RATIO,
                          (winSize.height - (rect.origin.y + rect.size.height)*wbConv.y)/LH_PTM_RATIO);
        
        verts[1] = b2Vec2((rect.origin.x+ rect.size.width)*wbConv.x/LH_PTM_RATIO, 
                          (winSize.height - (rect.origin.y + rect.size.height)*wbConv.y)/LH_PTM_RATIO);
        
        
        shape.Set(verts, 2);		
        b2FixtureDef fixture;
        [self setFixtureDefPropertiesFromDictionary:wb fixture:&fixture];
        fixture.shape = &shape;
        fixture.isSensor = false;
        wbBody->CreateFixture(&fixture);
        delete verts;
    }
    
    return wbBody;
}
-(b2Body*) createWorldBoundaries:(b2World*)_world
{
    return [self createWorldBoundaries:_world topTag:(int)DEFAULT_TAG leftTag:(int)DEFAULT_TAG bottomTag:(int)DEFAULT_TAG rightTag:(int)DEFAULT_TAG];
}

+(b2Body*) createFullScreenPhysicBoundaries:(b2World*)_world
{
    CGPoint wbConv = {1.0f, 1.0f};
    
    CGSize winSize = [[CCDirector sharedDirector] winSize];

    CGRect rect = {{0.0f, 0.0f}, {480.0f, 320.0f}};
        
    wbConv.x = winSize.width/rect.size.width;
    wbConv.y = winSize.height/rect.size.height;
    
    b2BodyDef bodyDef;	
	
	bodyDef.type = b2_staticBody;
	bodyDef.position.Set(0.0f, 0.0f);
    b2Body* body = _world->CreateBody(&bodyDef);
	
    
    {//TOP
        b2Vec2 *verts = new b2Vec2[2];
        
        b2PolygonShape shape;
        
        verts[0] = b2Vec2(rect.origin.x/LH_PTM_RATIO*wbConv.x,
                          (winSize.height - rect.origin.y*wbConv.y)/LH_PTM_RATIO);
        
        verts[1] = b2Vec2((rect.origin.x + rect.size.width)*wbConv.x/LH_PTM_RATIO, 
                          (winSize.height - rect.origin.y*wbConv.y)/LH_PTM_RATIO);
        
        
        shape.Set(verts, 2);		
        b2FixtureDef fixture;
        fixture.shape = &shape;
        fixture.isSensor = false;
        body->CreateFixture(&fixture);
        delete verts;
    }
    
    {//LEFT
        b2Vec2 *verts = new b2Vec2[2];
        
        b2PolygonShape shape;
        
        verts[0] = b2Vec2(rect.origin.x*wbConv.x/LH_PTM_RATIO,
                          (winSize.height - rect.origin.y*wbConv.y)/LH_PTM_RATIO);
        
        verts[1] = b2Vec2((rect.origin.x*wbConv.x)/LH_PTM_RATIO, 
                          (winSize.height - (rect.origin.y + rect.size.height)*wbConv.y)/LH_PTM_RATIO);
        
        
        shape.Set(verts, 2);		
        b2FixtureDef fixture;
        fixture.shape = &shape;
        body->CreateFixture(&fixture);
        delete verts;
    }
    
    {//RIGHT
        b2Vec2 *verts = new b2Vec2[2];
        
        b2PolygonShape shape;
        
        verts[0] = b2Vec2((rect.origin.x + rect.size.width)*wbConv.x/LH_PTM_RATIO,
                          (winSize.height - rect.origin.y*wbConv.y)/LH_PTM_RATIO);
        
        verts[1] = b2Vec2((rect.origin.x+ rect.size.width)*wbConv.x/LH_PTM_RATIO, 
                          (winSize.height - (rect.origin.y + rect.size.height)*wbConv.y)/LH_PTM_RATIO);
        
        
        shape.Set(verts, 2);		
        b2FixtureDef fixture;
        fixture.shape = &shape;
        body->CreateFixture(&fixture);
        delete verts;
    }
    
    {//BOTTOM
        b2Vec2 *verts = new b2Vec2[2];
        
        b2PolygonShape shape;
        
        verts[0] = b2Vec2(rect.origin.x*wbConv.x/LH_PTM_RATIO,
                          (winSize.height - (rect.origin.y + rect.size.height)*wbConv.y)/LH_PTM_RATIO);
        
        verts[1] = b2Vec2((rect.origin.x+ rect.size.width)*wbConv.x/LH_PTM_RATIO, 
                          (winSize.height - (rect.origin.y + rect.size.height)*wbConv.y)/LH_PTM_RATIO);
        
        
        shape.Set(verts, 2);		
        b2FixtureDef fixture;
        fixture.shape = &shape;
        fixture.isSensor = false;
        body->CreateFixture(&fixture);
        delete verts;
    }
    
    return body;
}


-(b2Body*) worldBoundariesBody
{
    return wbBody;
}

-(CGPoint) gameScreenSize
{
    return safeFrame;
}

-(CGRect) physicBoundariesRect
{
    CGPoint wbConv = {1.0f, 1.0f};
    
    if(convertLevel)
        wbConv = convertRatio;

    CGRect rect = LHRectFromString([wb objectForKey:@"WBRect"]);    

    rect.origin.x = rect.origin.x*wbConv.x,
    rect.origin.y = rect.origin.y*wbConv.y;
        
    rect.size.width = rect.size.width*wbConv.x;
    rect.size.height= rect.size.height*wbConv.y;

    return rect;
}

-(CGRect) gameWorldSize
{
    CGPoint wbConv = {1.0f, 1.0f};
    
    if(convertLevel)
        wbConv = convertRatio;

    CGRect ws = gameWorldRect;
    
    ws.origin.x *= wbConv.x;
    ws.origin.y *= wbConv.y;
    ws.size.width *= wbConv.x;
    ws.size.height *= wbConv.y;
    
    return ws;
}

////////////////////////////////////////////////////////////////////////////////
-(unsigned int) numberOfBatchNodesUsed
{
	return (int)[batchNodes count] -1;
}
////////////////////////////////////////////////////////////////////////////////
-(bool) isSpriteWithUniqueName:(NSString*)name atPoint:(CGPoint)point
{
    CCSprite* sprite = [self spriteWithUniqueName:name];

    if(nil == sprite)
        return false;
    
    CGPoint position = [sprite position];
    CGSize size = [sprite contentSize];
    
    if((point.x > position.x - size.width/2) &&
       (point.x < position.x + size.width/2) &&
       (point.y > position.y - size.height/2) &&
       (point.y < position.y + size.height/2))
        return true;
    
    return false;
}

-(bool) isBodyTouched:(b2Body*)body touchPoint:(CGPoint)point
{
    if(body == nil)
        return false;
    
    b2Fixture* stFix = body->GetFixtureList();
    
    while(stFix != 0)
    {
        if(stFix->TestPoint(b2Vec2(point.x/LH_PTM_RATIO, point.y/LH_PTM_RATIO)))
        {
            return true;
        }
        stFix = stFix->GetNext();
    }
    
    return false;    
}

-(bool) isBodyWithUniqueNameTouched:(NSString*)name touchPoint:(CGPoint)point
{
    b2Body* bd = [self bodyWithUniqueName:name];

    return [self isBodyTouched:bd touchPoint:point];
}

-(b2Body*) bodyWithTag:(enum LevelHelper_TAG)tag touchedAtPoint:(CGPoint*)point withFingerSize:(int)size
{
    NSArray* bodies =  [self bodiesWithTag:tag];
    
    for(NSValue* value in bodies)
    {
        b2Body* body = (b2Body*)[value pointerValue];
        
        for(int x = -size/2; x < size/2; ++x)
        {
            for(int y = -size/2; y < size/2; ++y)
            {
                CGPoint curPoint = {point->x + x, point->y + y};
                
                if([self isBodyTouched:body touchPoint:curPoint])
                {
                    *point = curPoint;
                    return body;
                }
            }
        }
    }
    
    return 0;    
}

-(b2Body*) bodyWithTag:(enum LevelHelper_TAG)tag touchedAtPoint:(CGPoint)point
{
    NSArray* bodies =  [self bodiesWithTag:tag];
    
    for(NSValue* value in bodies)
    {
        b2Body* body = (b2Body*)[value pointerValue];
     
        if([self isBodyTouched:body touchPoint:point])
        {
            return body;
        }
    }
    
    return 0;
}

-(b2MouseJoint*) mouseJointForBody:(b2Body*)ourBody touchPoint:(CGPoint)point
{
    if(0 == ourBody)
        return 0;
    
    b2MouseJointDef md;
    md.bodyA = [self worldBoundariesBody];
    md.bodyB = ourBody;
    
    if(nil == md.bodyA)
        NSLog(@"LevelHelper ERROR: mouseJointForBody will crash - You need to create world boundaries - use createWorldBoundaries method in the \"init\" method");
    
    b2Vec2 locationWorld = b2Vec2(point.x/LH_PTM_RATIO, point.y/LH_PTM_RATIO);
    
    
    md.target = locationWorld;
    md.collideConnected = true;
    md.maxForce = 1000.0f * ourBody->GetMass();
    ourBody->SetAwake(true);
    
    return (b2MouseJoint *)box2dWorld->CreateJoint(&md);
}

-(b2MouseJoint*) mouseJointForBodyWithUniqueName:(NSString*)name touchPoint:(CGPoint)point
{
    b2Body* ourBody = [self bodyWithUniqueName:name];
    
    return [self mouseJointForBody:ourBody touchPoint:point];
}

-(void) setTarget:(CGPoint)point onMouseJoint:(b2MouseJoint*)mouseJoint
{
    if(mouseJoint == 0)
        return;
    b2Vec2 locationWorld = b2Vec2(point.x/LH_PTM_RATIO, point.y/LH_PTM_RATIO);
    
    mouseJoint->SetTarget(locationWorld);
}

////////////////////////////////////////////////////////////////////////////////
-(CCSprite*) spriteWithUniqueName:(NSString*)name
{
	if(addSpritesToLayerWasUsed)
	{
		return [ccSpritesInScene objectForKey:name];	
	}
	else if(addObjectsToWordWasUsed)
	{
		b2Body* body = (b2Body*)[[ccSpritesInScene objectForKey:name] pointerValue];
		
		if(nil != body)
			return (CCSprite*)[LevelHelperLoader spriteForBody:body];//->GetUserData()
		else {
			CCSprite* sprite = (CCSprite*)[noPhysicSprites objectForKey:name];
			
			return sprite;
		}
	}
	
	return nil;
}
////////////////////////////////////////////////////////////////////////////////
-(b2Body*) bodyWithUniqueName:(NSString*)name
{
	if(addObjectsToWordWasUsed)
	{
		b2Body* body = (b2Body*)[[ccSpritesInScene objectForKey:name] pointerValue];
		
		return body;
	}
	
	return nil;
}
////////////////////////////////////////////////////////////////////////////////
-(void) removeSpriteUserData:(CCSprite*)ccsprite
{
    NSMutableArray* usrData = (NSMutableArray*)[ccsprite userData];
    
    if(usrData != nil)
        [usrData release];
}
-(bool) removeSpriteWithUniqueName:(NSString*)name
{
	//NSAssert(addObjectsToWordWasUsed!=true, @"You cannot remove a sprite with method removeCCSpriteWithUniqueName if you used the method addObjectToWorld to load your level. Use method removeBody."); 
	
	CCSprite* ccsprite = nil;
	if(!addObjectsToWordWasUsed)
	{
		ccsprite = [ccSpritesInScene objectForKey:name];
	}
	else {
		ccsprite = [noPhysicSprites objectForKey:name];
	}
	if(nil == ccsprite)
	{
		return false;
	}
    
    [self removeSpriteUserData:ccsprite];
    
	if([ccsprite usesBatchNode])
	{
        [self removeFromBatchNode:ccsprite];
	}
	else {
		[cocosLayer removeChild:ccsprite cleanup:YES];
		return false;
	}
	
	
	if(!addObjectsToWordWasUsed)
	{
		[ccSpritesInScene removeObjectForKey:name];
	}
	else {
		[noPhysicSprites removeObjectForKey:name];
	}
	
	
	return true;
}
////////////////////////////////////////////////////////////////////////////////
-(bool) removeSprite:(CCSprite*)ccsprite
{
	if(nil == ccsprite)
		return false;
    
    
    [self removeSpriteUserData:ccsprite];
    
	if([ccsprite usesBatchNode])
	{
		NSArray * keys= nil;
		if(!addObjectsToWordWasUsed)
			keys = [ccSpritesInScene allKeysForObject:ccsprite];
		else {
			keys = [noPhysicSprites allKeysForObject:ccsprite];
		}
		
        [self removeFromBatchNode:ccsprite];
		
		for(NSString* key in keys)
		{
			if(!addObjectsToWordWasUsed)
				[ccSpritesInScene removeObjectForKey:key];
			else {
				[noPhysicSprites removeObjectForKey:key];
			}
			
		}
	}
	else 
	{
		[cocosLayer removeChild:ccsprite cleanup:YES];
		return false;
	}
	
	return true;
}
////////////////////////////////////////////////////////////////////////////////
-(bool) removeAllSprites
{	
	//NSAssert(addObjectsToWordWasUsed!=true, @"You cannot remove all sprites with method removeAllCCSprites if you used the method addObjectToWorld to load your level. Use method removeAllBodies."); 
	
	NSArray *keys = nil;
	if(!addObjectsToWordWasUsed)
		keys = [ccSpritesInScene allKeys];
	else {
		keys = [noPhysicSprites allKeys];
	}
    
    if(keys == nil)
        return false;
	
	bool removedAll = true;
	for(NSString* key in keys)
	{
        if(key != nil)
        {
            removedAll = removedAll == [self removeSpriteWithUniqueName:key];
        }
	}
	
	return removedAll;	
}
-(bool) removeSpritesWithTag:(enum LevelHelper_TAG)tag
{
	NSArray *keys = nil;
	if(!addObjectsToWordWasUsed)
		keys = [ccSpritesInScene allKeys];
	else {
		keys = [noPhysicSprites allKeys];
	}
	
	bool removedAll = true;
	for(NSString* key in keys)
	{
        if(tag == [LevelHelperLoader tagForSprite:[self spriteWithUniqueName:key]])
        {
            removedAll = removedAll == [self removeSpriteWithUniqueName:key];
        }
	}
	
	return removedAll;	
}
-(bool) removeAllParallaxSprites
{
    NSArray* keys = [ccParallaxInScene allKeys];
    
    for(NSString* key in keys)
    {
        CCParallaxNode* node = [self paralaxNodeWithUniqueName:key];
        if(nil != node)
        {
            NSArray* sprites = [self spritesInParallaxNodeWithUniqueName:key];
            
            for(CCSprite* spr in sprites)
            {
                [node removeChild:spr cleanup:YES];
            }
            
            [cocosLayer removeChild:node cleanup:YES];
        }
        else
        {
            NSArray* sprites = [self spritesInParallaxNodeWithUniqueName:key];
        
            for(CCSprite* spr in sprites)
            {
                [cocosLayer removeChild:spr cleanup:YES];
            }
        }
    }
    return true;
}
////////////////////////////////////////////////////////////////////////////////
-(void) removeFromBatchNode:(CCSprite*)sprite
{
	CCSpriteBatchNode *batchNode = [sprite batchNode];
	
	if(nil == batchNode)
		return;
	
    [self checkIfSpriteWasMovingOnPathAndRemoveIt:sprite];
	[batchNode removeChild:sprite cleanup:YES];
}
////////////////////////////////////////////////////////////////////////////////
-(bool) removeBodyWithUniqueName:(NSString*)name
{
	NSAssert(addSpritesToLayerWasUsed!=true, @"You cannot remove a body with method removeBodyWithUniqueName if you used the method addSpritesToLayer to load your level. Use method removeCCSprite or removeCCSpriteWithUniqueName."); 
	
	b2Body* body = (b2Body*)[[ccSpritesInScene objectForKey:name] pointerValue];
	
	if(0 != body)
	{
    	return [self removeBody:body];
	}
	
	return false;
}

-(void) checkIfSpriteWasMovingOnPathAndRemoveIt:(CCSprite*)sprite
{
    NSValue* valToRem = nil;
    
    if(moveOnPathInfo == nil)
        return;
    
    for(NSValue* value in moveOnPathInfo)
    {
        if(value == nil)
            return;
        
        lhPathInfo* info = (lhPathInfo*)[value pointerValue];
        
        if(0 != info)
        {
            if(info->ccSprite == sprite)
            {
                valToRem = value;
                break; // a sprite can move only on one path
            }
            
        }
    }
    
    if(valToRem != nil)
        [moveOnPathInfo removeObject:valToRem];
}

-(bool) removeBody:(b2Body*)body
{
	NSAssert(addSpritesToLayerWasUsed!=true, @"You cannot remove a body with method removeBody if you used the method addSpritesToLayer to load your level. Use method removeCCSprite or removeCCSpriteWithUniqueName."); 
	
	if(0 == body)
		return false;
	
	CCSprite *ccsprite = (CCSprite*)[LevelHelperLoader spriteForBody:body];//->GetUserData();
	
	if(nil == ccsprite)
		return false;
    
    
    b2World* _world = body->GetWorld();
    
	if([ccsprite usesBatchNode])
	{
		NSArray * keys = [ccSpritesInScene allKeysForObject:[NSValue valueWithPointer:body]];
		
		if(0 == _world)
			return false;
		
		[self removeFromBatchNode:ccsprite];
        
		for(NSString* key in keys)
		{
			[ccSpritesInScene removeObjectForKey:key];
		}
	}
    else
    {
        [self checkIfSpriteWasMovingOnPathAndRemoveIt:ccsprite];
        [cocosLayer removeChild:ccsprite cleanup:YES];
    }    
    
    if(0 == body)
        return false;
    
    _world->DestroyBody(body);
    	
	return true;
}

-(bool) removeWorldBoundaries
{
    if(0 == wbBody)
        return false;
    
    b2World* _world = wbBody->GetWorld();
    
    if(0 != _world)
    {
        _world->DestroyBody(wbBody);
        return true;
    }
    
    return false;
}


-(bool) removeBodiesWithTag:(enum LevelHelper_TAG)tag
{
    NSAssert(addSpritesToLayerWasUsed!=true, @"You cannot remove bodies with method removeBodiesWithTag if you used the method addSpritesToLayer to load your level. Use method removeAllCCSprites."); 
	
	NSArray *keys = [ccSpritesInScene allKeys];
	
	bool removedAll = true;
	for(NSString* key in keys)
	{
        b2Body* body = [self bodyWithUniqueName:key];
        if(tag == [LevelHelperLoader tagForBody:body])
        {
            removedAll = removedAll == [self removeBody:body];    
        }
	}
	return removedAll;		
}
////////////////////////////////////////////////////////////////////////////////
-(bool) removeAllBodies
{
	NSAssert(addSpritesToLayerWasUsed!=true, @"You cannot remove all bodies with method removeAllBodies if you used the method addSpritesToLayer to load your level. Use method removeAllCCSprites."); 
	
	NSArray *keys = [ccSpritesInScene allKeys];
	
	bool removedAll = true;
	for(NSString* key in keys)
	{
		removedAll = removedAll == [self removeBodyWithUniqueName:key];
	}
	return removedAll;		
}
////////////////////////////////////////////////////////////////////////////////
-(b2Joint*) jointWithUniqueName:(NSString*)name
{
	NSAssert(addSpritesToLayerWasUsed!=true, @"You cannot remove a joint with method removeJointWithUniqueName if you used the method addSpritesToLayer to load your level."); 
	
	
	b2Joint* joint = (b2Joint*)[[ccJointsInScene objectForKey:name] pointerValue];
	
	return joint;
}
////////////////////////////////////////////////////////////////////////////////
-(bool) removeJointWithUniqueName:(NSString*)name
{
	NSAssert(addSpritesToLayerWasUsed!=true, @"You cannot remove a joint with method removeJointWithUniqueName if you used the method addSpritesToLayer to load your level."); 
	
	
	b2Joint* joint = (b2Joint*)[[ccJointsInScene objectForKey:name] pointerValue];
	
	if(0 != joint)
	{
		return [self removeJoint:joint];
	}
	
	return false;
}
////////////////////////////////////////////////////////////////////////////////
-(NSArray*) jointsWithTag:(enum LevelHelper_TAG)tag
{
    NSAssert(addSpritesToLayerWasUsed!=true, @"You cannot use method jointsWithTag if you used the method addSpritesToLayer to load your level."); 
    
	NSArray *keys = [ccJointsInScene allKeys];
	
    NSMutableArray* jointsWithTag = [[[NSMutableArray alloc] init] autorelease];
	for(NSString* key in keys)
	{
		b2Joint* joint = [self jointWithUniqueName:key];
        
        if([LevelHelperLoader tagForJoint:joint] == tag)
        {
            [jointsWithTag addObject:[NSValue valueWithPointer:joint]];
        }
	}
    
    return jointsWithTag;
}
////////////////////////////////////////////////////////////////////////////////
//use this method to remove multiple joints at once
-(void) removeJointsWithTag:(enum LevelHelper_TAG)tag
{
    NSAssert(addSpritesToLayerWasUsed!=true, @"You cannot remove joints with method removeAllJointsWithTag if you used the method addSpritesToLayer to load your level."); 
    
	NSArray *keys = [ccJointsInScene allKeys];
	
	for(NSString* key in keys)
	{
		b2Joint* joint = [self jointWithUniqueName:key];
    
        if([LevelHelperLoader tagForJoint:joint] == tag)
        {
            [self removeJoint:joint];
        }
	}
}
////////////////////////////////////////////////////////////////////////////////
-(bool) removeAllJoints
{
	NSAssert(addSpritesToLayerWasUsed!=true, @"You cannot remove joints with method removeAllJoints if you used the method addSpritesToLayer to load your level."); 

	NSArray *keys = [ccJointsInScene allKeys];
	
	bool removedAll = true;
	for(NSString* key in keys)
	{
		removedAll = removedAll == [self removeJointWithUniqueName:key];
	}
	return removedAll;	
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
-(bool) removeJoint:(b2Joint*) joint
{
	NSAssert(addSpritesToLayerWasUsed!=true, @"You cannot remove a joint with method removeJoint if you used the method addSpritesToLayer to load your level."); 
	
	if(0 == joint)
		return false;
	
	b2Body *body = joint->GetBodyA();
	
	if(0 == body)
	{
		body = joint->GetBodyB();
		
		if(0 == body)
			return false;
	}
	
	NSArray * keys = [ccJointsInScene allKeysForObject:[NSValue valueWithPointer:joint]];
	
	b2World* _world = body->GetWorld();
	
	if(0 == _world)
		return false;
	

    LHJoint* jData = (LHJoint*)joint->GetUserData();
    delete jData;
    
	for(NSString* key in keys)
	{
		[ccJointsInScene removeObjectForKey:key];
	}
	_world->DestroyJoint(joint);
	
	
	return true;
}

-(CCSprite*) newSpriteWithUniqueName:(NSString *)uniqueName
{
	for(NSDictionary* dictionary in lhSprites)
	{
		NSDictionary* spriteProp = [dictionary objectForKey:@"GeneralProperties"];
		
		if([[spriteProp objectForKey:@"UniqueName"] isEqualToString:uniqueName])
		{
            NSDictionary* spriteProp = [dictionary objectForKey:@"GeneralProperties"];
            
            //find the coresponding batch node for this sprite
            NSDictionary* batchInfo = [batchNodes objectForKey:[spriteProp objectForKey:@"Image"]];
            CCSpriteBatchNode *batch = [batchInfo objectForKey:@"CCBatchNode"];
            
            if(nil != batch)
            {
                CCSprite* ccsprite = [self spriteWithBatchFromDictionary:spriteProp batchNode:batch];
                [batch addChild:ccsprite z:[[spriteProp objectForKey:@"ZOrder"] intValue]];
                
                return ccsprite;
            }
        }
    }
    return nil;
}

////////////////////////////////////////////////////////////////////////////////////
-(CCSprite*) newSpriteWithUniqueName:(NSString*)uniqueName 
						  cocos2dLayer:(CCLayer*)_cocosLayer
{
	for(NSDictionary* dictionary in lhSprites)
	{
		NSDictionary* spriteProp = [dictionary objectForKey:@"GeneralProperties"];
		
		if([[spriteProp objectForKey:@"UniqueName"] isEqualToString:uniqueName])
		{
            NSDictionary* spriteProp = [dictionary objectForKey:@"GeneralProperties"];
			CCSprite* ccsprite = [self spriteFromDictionary:spriteProp];
			
			if(nil != ccsprite)
				[_cocosLayer addChild:ccsprite];
			
			return ccsprite;
		}
	}
	return nil;
}
////////////////////////////////////////////////////////////////////////////////
-(b2Body*) newBodyWithUniqueName:(NSString*)name 
						   world:(b2World*)_world
{
	for(NSDictionary* dictionary in lhSprites)
	{
		NSDictionary* spriteProp = [dictionary objectForKey:@"GeneralProperties"];
		
		if([[spriteProp objectForKey:@"UniqueName"] isEqualToString:name])
		{
			NSDictionary* spriteProp = [dictionary objectForKey:@"GeneralProperties"];
            
            //find the coresponding batch node for this sprite
            NSDictionary* batchInfo = [batchNodes objectForKey:[spriteProp objectForKey:@"Image"]];
            CCSpriteBatchNode *batch = [batchInfo objectForKey:@"CCBatchNode"];
            
            if(nil != batch)
            {
                CCSprite* ccsprite = [self spriteWithBatchFromDictionary:spriteProp batchNode:batch];
                [batch addChild:ccsprite z:[[spriteProp objectForKey:@"ZOrder"] intValue]];
            
			NSDictionary* physicProp = [dictionary objectForKey:@"PhysicProperties"];
			
            b2Body* body =  [self b2BodyFromDictionary:physicProp
                                      spriteProperties:spriteProp
                                                  data:ccsprite 
                                                 world:_world];
                
                NSValue *value = [NSValue valueWithPointer:body];
                [ccSpritesInScene setObject:value forKey:[NSString stringWithFormat:@"%@_LH_NEW_BODY_%d", name, newBodyNameId]];
                newBodyNameId++;
                
                return body;
            }
		}
	}
	
	return 0;
    
}
-(b2Body*) newBodyWithUniqueName:(NSString*)uniqueName 
						   world:(b2World*)_world
					cocos2dLayer:(CCLayer*)_cocosLayer
{
	for(NSDictionary* dictionary in lhSprites)
	{
		NSDictionary* spriteProp = [dictionary objectForKey:@"GeneralProperties"];
		
		if([[spriteProp objectForKey:@"UniqueName"] isEqualToString:uniqueName])
		{
			CCSprite* ccsprite = [self spriteFromDictionary:spriteProp];	
			
			if(nil == ccsprite)
				return 0;
			
			[_cocosLayer addChild:ccsprite];
			
			NSDictionary* physicProp = [dictionary objectForKey:@"PhysicProperties"];
			
			return [self b2BodyFromDictionary:physicProp
							 spriteProperties:spriteProp
										 data:ccsprite 
										world:_world];
		}
	}
	
	return 0;
}
////////////////////////////////////////////////////////////////////////////////////
-(NSArray*)spritesWithTag:(enum LevelHelper_TAG)tag
{
	NSMutableArray* array = [[[NSMutableArray alloc] init] autorelease];
	
	NSArray *keys = [ccSpritesInScene allKeys];
	for(NSString* key in keys)
	{
		CCSprite* ccSprite = nil;
		if(addSpritesToLayerWasUsed)
		{
			ccSprite = [ccSpritesInScene objectForKey:key];
		}
		else 
		{
			b2Body* body = (b2Body*)[[ccSpritesInScene objectForKey:key] pointerValue];
			if(0 != body)
            {
				ccSprite = (CCSprite*)[LevelHelperLoader spriteForBody:body];//->GetUserData();
            }			
		}
		
		if(nil != ccSprite && [ccSprite tag] == (int)tag)
		{
			[array addObject:ccSprite];
		}
	}
    
    if(addObjectsToWordWasUsed)
    {

        NSArray *no_phys_keys = [noPhysicSprites allKeys];
        for(NSString* key in no_phys_keys)
        {
            CCSprite* ccSprite = [noPhysicSprites objectForKey:key];
		
            if(nil != ccSprite && [ccSprite tag] == (int)tag)
            {
                [array addObject:ccSprite];
            }
        }
    }
	
	return array;
}
////////////////////////////////////////////////////////////////////////////////////
-(NSArray*) bodiesWithTag:(enum LevelHelper_TAG)tag
{
	NSAssert(addSpritesToLayerWasUsed!=true, @"You cannot use method BodiesWithTag if you used the method addSpritesToLayer to load your level."); 
	
	NSMutableArray* array = [[[NSMutableArray alloc] init] autorelease];
	
	NSArray *keys = [ccSpritesInScene allKeys];
	for(NSString* key in keys)
	{
		b2Body* body = (b2Body*)[[ccSpritesInScene objectForKey:key] pointerValue];
		CCSprite* ccSprite = (CCSprite*)[LevelHelperLoader spriteForBody:body];//->GetUserData();
		
		if(nil != ccSprite && [ccSprite tag] == (int)tag)
		{
			[array addObject:[NSValue valueWithPointer:body]];
		}
	}
	
	return array;
}
////////////////////////////////////////////////////////////////////////////////////
-(NSArray*)newSpritesWithTag:(enum LevelHelper_TAG)tag
						 cocos2dLayer:(CCLayer*)_cocosLayer
{
	NSMutableArray* array = [[[NSMutableArray alloc] init] autorelease];
	
	for(NSDictionary* dictionary in lhSprites)
	{
		NSDictionary* spriteProp = [dictionary objectForKey:@"GeneralProperties"];
		
		if((LevelHelper_TAG)[[spriteProp objectForKey:@"Tag"] intValue] == tag)
		{
			CCSprite* ccsprite = [self spriteFromDictionary:spriteProp];
			
			if(nil != ccsprite)
			{
				[array addObject:ccsprite];
				[_cocosLayer addChild:ccsprite];
			}
		}
	}
	
	return array;
}
////////////////////////////////////////////////////////////////////////////////////
-(NSArray*) newBodiesWithTag:(enum LevelHelper_TAG)tag 
                       world:(b2World*)_world
                cocos2dLayer:(CCLayer*)_cocosLayer
{
	NSMutableArray* array = [[[NSMutableArray alloc] init] autorelease];
	
	for(NSDictionary* dictionary in lhSprites)
	{
		NSDictionary* spriteProp = [dictionary objectForKey:@"GeneralProperties"];
		
		if((LevelHelper_TAG)[[spriteProp objectForKey:@"Tag"] intValue] == tag)
		{
			CCSprite* ccsprite = [self spriteFromDictionary:spriteProp];
			
			if(nil != ccsprite)
			{
				NSDictionary* physicProp = [dictionary objectForKey:@"PhysicProperties"];
				
				NSValue* v = [NSValue valueWithPointer:[self b2BodyFromDictionary:physicProp
																 spriteProperties:spriteProp
																			 data:ccsprite 
																			world:_world]];
				
				
				
				[array addObject:v];
				
				[_cocosLayer addChild:ccsprite];
			}
		}
	}
	return array;
}
-(void) releaseAllParallaxes
{
    [self removeAllParallaxSprites];
    [ccParallaxInScene release];
    ccParallaxInScene = nil;
}
////////////////////////////////////////////////////////////////////////////////////
-(void) releaseAll
{
    [self removeWorldBoundaries];
    
    [self releaseAllPathsMovement];
    [moveOnPathInfo release];
    moveOnPathInfo = nil;
    
    
    NSArray *spritekeys = [ccSpritesInScene allKeys];
	for(NSString* key in spritekeys)
    {
        CCSprite* spr = [self spriteWithUniqueName:key];
        
        [spr stopAllActions];
    }
    
	[lhSprites release];
	[lhJoints release];
    [lhParallax release];
    [lhBeziers release];
	
	if(addObjectsToWordWasUsed){
		[self removeAllJoints];	
		[self removeAllBodies];
		[self removeAllSprites]; //for no physic sprites
        
        NSArray *bezierkeys = [ccBeziersBodyInScene allKeys];
        for(NSString* key in bezierkeys)
        {  
            NSValue *value = [ccBeziersBodyInScene objectForKey:key];
            b2Body* body = (b2Body*)[value pointerValue];
            
            CCSprite* spr = (CCSprite*)body->GetUserData();
            [self removeSpriteUserData:spr];
            [spr release];
            
            b2World* _w = body->GetWorld();
            
            if(_w != 0)
            {
                _w->DestroyBody(body);
            }
        }
	}
	else {
		[self removeAllSprites];
	}
    
    [ccBeziersBodyInScene release];
    
	[ccSpritesInScene release];
    ccSpritesInScene = nil;
    
	[ccJointsInScene release];
    ccJointsInScene = nil;
    
	[noPhysicSprites release];
    noPhysicSprites = nil;
    
    [self releaseAllParallaxes];
    
   
	[ccBezierPathsInScene release];
    ccBezierPathsInScene = nil;
    
    [ccFramesForAnimation release];
    ccFramesForAnimation = nil;
    
	NSArray *keys = [batchNodes allKeys];
	for(NSString* key in keys)
	{
		NSDictionary* info = [batchNodes objectForKey:key];
		
		CCSpriteBatchNode *v = [info objectForKey:@"CCBatchNode"];
		[cocosLayer removeChild:v cleanup:true];
	}
	[batchNodes release];
    batchNodes = nil;
}
////////////////////////////////////////////////////////////////////////////////////
-(oneway void) release
{
    [self releaseAll];
}

-(void) dealloc
{
    [super dealloc];
}
///////////////////////////PRIVATE METHODS//////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
-(void) addBatchNodesToLayer:(CCLayer*)_cocosLayer
{
	NSArray *keys = [batchNodes allKeys];
	int tag = 0;
	for(NSString* key in keys)
	{
		NSDictionary* info = [batchNodes objectForKey:key];
		
		CCSpriteBatchNode *v = [info objectForKey:@"CCBatchNode"];
		int z = [[info objectForKey:@"OrderZ"] intValue];
		[_cocosLayer addChild:v z:z tag:tag];
		tag++;
	}
}
////////////////////////////////////////////////////////////////////////////////////
-(CCSprite*) spriteFromDictionary:(NSDictionary*)spriteProp
{
    CGRect uv = LHRectFromString([spriteProp objectForKey:@"UV"]);
    
    if([self isIpad])
    {
        uv.origin.x *=2.0f;
        uv.origin.y *=2.0f;
        uv.size.width *=2.0f;
        uv.size.height *=2.0f;
    }
    
	CCSprite *ccsprite = [CCSprite spriteWithFile:[self imageFile:[spriteProp objectForKey:@"Image"]]
											 rect:uv];
	
	[self setSpriteProperties:ccsprite spriteProperties:spriteProp];
	
	return ccsprite;
}
////////////////////////////////////////////////////////////////////////////////////
-(CCSprite*) spriteWithBatchFromDictionary:(NSDictionary*)spriteProp 
								   batchNode:(CCSpriteBatchNode*)batch
{
    CGRect uv = LHRectFromString([spriteProp objectForKey:@"UV"]);
        
    if([self isIpad])
    {
        uv.origin.x *=2.0f;
        uv.origin.y *=2.0f;
        uv.size.width *=2.0f;
        uv.size.height *=2.0f;
    }

    
 	CCSprite *ccsprite = [CCSprite spriteWithBatchNode:batch 
												  rect:uv];
	
	[self setSpriteProperties:ccsprite spriteProperties:spriteProp];
	
	return ccsprite;	
}
////////////////////////////////////////////////////////////////////////////////////
-(void) setSpriteProperties:(CCSprite*)ccsprite
			 spriteProperties:(NSDictionary*)spriteProp
{
	//convert position from LH to Cocos2d coordinates
	CGSize winSize = [[CCDirector sharedDirector] winSize];
	CGPoint position = LHPointFromString([spriteProp objectForKey:@"Position"]);

    if(convertLevel)
    {
        position.x *= convertRatio.x;
        position.y *= convertRatio.y;
    }
    
    position.y = winSize.height - position.y;
    
	[ccsprite setPosition:position];
	[ccsprite setRotation:[[spriteProp objectForKey:@"Angle"] floatValue]];
	[ccsprite setOpacity:255*[[spriteProp objectForKey:@"Opacity"] floatValue]*lh_customAlpha];
	CGRect color = LHRectFromString([spriteProp objectForKey:@"Color"]);
	[ccsprite setColor:ccc3(255*color.origin.x, 255*color.origin.y, 255*color.size.width)];
	CGPoint scale = LHPointFromString([spriteProp objectForKey:@"Scale"]);
      
    if(convertLevel)
    {
        UIInterfaceOrientation orientation;
        if([[UIDevice currentDevice] orientation] == UIDeviceOrientationPortrait)
        {
            scale.x *= convertRatio.y;
            scale.y *= convertRatio.x;
        }
        else
        {
            scale.x *= convertRatio.x;
            scale.y *= convertRatio.y;
        }
    }

    if([self isIpad])
    {
        scale.x /=2;
        scale.y /=2;
    }

	[ccsprite setScaleX:scale.x];
	[ccsprite setScaleY:scale.y];
     
    NSMutableDictionary* spriteUserData = [[NSMutableDictionary alloc] init];
    [spriteUserData setObject:[spriteProp objectForKey:@"UniqueName"] forKey:@"UniqueName"];
    [spriteUserData setObject:[spriteProp objectForKey:@"AnimName"] forKey:@"AnimName"];
    [spriteUserData setObject:[NSNumber numberWithInt:0] forKey:@"CurrentFrame"];
    [ccsprite setUserData:spriteUserData];
    
	[ccsprite setTag:[[spriteProp objectForKey:@"Tag"] intValue]];
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
-(void) setFixtureDefPropertiesFromDictionary:(NSDictionary*)spritePhysic 
									  fixture:(b2FixtureDef*)shapeDef
{
	shapeDef->density = [[spritePhysic objectForKey:@"Density"] floatValue];
	shapeDef->friction = [[spritePhysic objectForKey:@"Friction"] floatValue];
	shapeDef->restitution = [[spritePhysic objectForKey:@"Restitution"] floatValue];
	
	shapeDef->filter.categoryBits = [[spritePhysic objectForKey:@"Category"] intValue];
	shapeDef->filter.maskBits = [[spritePhysic objectForKey:@"Mask"] intValue];
	shapeDef->filter.groupIndex = [[spritePhysic objectForKey:@"Group"] intValue];
    
    shapeDef->isSensor = [[spritePhysic objectForKey:@"IsSenzor"] boolValue];
}

////////////////////////////////////////////////////////////////////////////////
-(b2Body*) b2BodyFromDictionary:(NSDictionary*)spritePhysic
			   spriteProperties:(NSDictionary*)spriteProp
						   data:(CCSprite*)ccsprite 
						  world:(b2World*)_world
{
	b2BodyDef bodyDef;	
	    
	int bodyType = [[spritePhysic objectForKey:@"Type"] intValue];
	if(bodyType == 3) //in case the user wants to create a body with a sprite that has type as "NO_PHYSIC"
		bodyType = 2;
	bodyDef.type = (b2BodyType)bodyType;
	bodyDef.position.Set([ccsprite position].x/LH_PTM_RATIO,[ccsprite position].y/LH_PTM_RATIO);
	bodyDef.angle = DEGREES_TO_RADIANS(-1*[[spriteProp objectForKey:@"Angle"] floatValue]);
	
    bodyDef.userData = ccsprite;
    
	b2Body* body = _world->CreateBody(&bodyDef);

    NSMutableDictionary* spriteUserData = (NSMutableDictionary*)[ccsprite userData];
    [spriteUserData setObject:[NSValue valueWithPointer:body] forKey:@"Body"];
    	
	body->SetFixedRotation([[spritePhysic objectForKey:@"FixedRot"] boolValue]);
	
	NSArray* fixtures = [spritePhysic objectForKey:@"ShapeFixtures"];
	CGPoint scale = LHPointFromString([spriteProp objectForKey:@"Scale"]); 
    
    CGPoint size = LHPointFromString([spriteProp objectForKey:@"Size"]);
    
    CGPoint border = LHPointFromString([spritePhysic objectForKey:@"ShapeBorder"]);
    
    if(convertLevel)// && convertPhysic)
    {
        scale.x *= convertRatio.x;
        scale.y *= convertRatio.y;        
    }

	if(fixtures == nil || [fixtures count] == 0 || [[fixtures objectAtIndex:0] count] == 0)
	{
		b2PolygonShape shape;
		b2FixtureDef fixture;
		b2CircleShape circle;
		[self setFixtureDefPropertiesFromDictionary:spritePhysic fixture:&fixture];
		
		if([[spritePhysic objectForKey:@"IsCircle"] boolValue])
		{
            if(convertLevel)
            {
            //    NSLog(@"convert circle");
                //this is for the ipad scale on circle look weird if we dont do this
                float scaleSpr = [ccsprite scaleX];
                [ccsprite setScaleY:scaleSpr];
            }
            
			circle.m_radius = (size.x*scale.x/2 - border.x*scale.x)/LH_PTM_RATIO;
			fixture.shape = &circle;
            body->CreateFixture(&fixture);
		}
		else
		{
            //THIS WAS ADDED BECAUSE I DISCOVER A BUG IN BOX2d
            //that makes linearImpulse to not work the body is in contact with
            //a box object
            int vsize = 4;
			b2Vec2 *verts = new b2Vec2[vsize];
			b2PolygonShape shape;
			
            verts[0].x = ( (-1* size.x + border.x/2.0f)*scale.x/2.0f)/LH_PTM_RATIO;
            verts[0].y = ( (-1* size.y + border.y/2.0f)*scale.y/2.0f)/LH_PTM_RATIO;

            verts[1].x = ( (+ size.x - border.x/2.0f)*scale.x/2.0f)/LH_PTM_RATIO;
            verts[1].y = ( (-1* size.y + border.y/2.0f)*scale.y/2.0f)/LH_PTM_RATIO;

            verts[2].x = ( (+ size.x - border.x/2.0f)*scale.x/2.0f)/LH_PTM_RATIO;
            verts[2].y = ( (+ size.y - border.y/2.0f)*scale.y/2.0f)/LH_PTM_RATIO;

            verts[3].x = ( (-1* size.x + border.x/2.0f)*scale.x/2.0f)/LH_PTM_RATIO;
            verts[3].y = ( (+ size.y - border.y/2.0f)*scale.y/2.0f)/LH_PTM_RATIO;
            
			shape.Set(verts, vsize);		

//            shape.SetAsBox((size.x*scale.x - border.x)/LH_PTM_RATIO/2, 
//						   (size.y*scale.y - border.y)/LH_PTM_RATIO/2);
            
			fixture.shape = &shape;
            body->CreateFixture(&fixture);
            delete verts;
		}
	}
	else
	{
		for(NSArray* curFixture in fixtures)
		{
			int size = (int)[curFixture count];
			b2Vec2 *verts = new b2Vec2[size];
			b2PolygonShape shape;
			int i = 0;
			for(NSString* pointStr in curFixture)
			{
				CGPoint point = LHPointFromString(pointStr);
				verts[i] = b2Vec2(point.x*(scale.x)/LH_PTM_RATIO, 
								  point.y*(scale.y)/LH_PTM_RATIO);
				++i;
			}
			shape.Set(verts, size);		
			b2FixtureDef fixture;
			[self setFixtureDefPropertiesFromDictionary:spritePhysic fixture:&fixture];
			fixture.shape = &shape;
			body->CreateFixture(&fixture);
			delete verts;
		}
	}

    [self setCustomAttributesForPhysics:spriteProp 
                         body:body
                       sprite:ccsprite];
	
	return body;
	
}


-(void) setCustomAttributesForPhysics:(NSDictionary*)spriteProp 
                       body:(b2Body*)body
                     sprite:(CCSprite*)sprite
{
    
}
-(void) setCustomAttributesForNonPhysics:(NSDictionary*)spriteProp 
                                  sprite:(CCSprite*)sprite
{
    
}

-(void) setCustomAttributesForBezierBodies:(NSDictionary*)bezierProp 
                                    sprite:(CCSprite*)sprite body:(b2Body*)body
{
    
}
////////////////////////////////////////////////////////////////////////////////////
-(b2Joint*) b2JointFromDictionary:(NSDictionary*)joint world:(b2World*)world
{
    b2Joint* boxJoint = 0;
    
	if(nil == joint)
		return 0;
	
	if(world == 0)
		return 0;
	
	b2Body* bodyA = (b2Body*)[[ccSpritesInScene objectForKey:[joint objectForKey:@"ObjectA"]] pointerValue];
	b2Body* bodyB = (b2Body*)[[ccSpritesInScene objectForKey:[joint objectForKey:@"ObjectB"]] pointerValue];
	
	CGPoint anchorA = LHPointFromString([joint objectForKey:@"AnchorA"]);
	CGPoint anchorB = LHPointFromString([joint objectForKey:@"AnchorB"]);
	bool collideConnected = [[joint objectForKey:@"CollideConnected"] boolValue];
	
    int tag = [[joint objectForKey:@"Tag"] intValue];
    int type = [[joint objectForKey:@"Type"] intValue];
    
	b2Vec2 posA, posB;
	
    if(![[joint objectForKey:@"CenterOfMass"] boolValue])
    {
        posA = b2Vec2((bodyA->GetWorldCenter().x*LH_PTM_RATIO + anchorA.x)/LH_PTM_RATIO, 
                      (bodyA->GetWorldCenter().y*LH_PTM_RATIO - anchorA.y)/LH_PTM_RATIO);
        
        posB = b2Vec2((bodyB->GetWorldCenter().x*LH_PTM_RATIO + anchorB.x)/LH_PTM_RATIO, 
                      (bodyB->GetWorldCenter().y*LH_PTM_RATIO - anchorB.y)/LH_PTM_RATIO);
    }
    else {		
        posA = b2Vec2((bodyA->GetWorldCenter().x)/LH_PTM_RATIO, 
                      (bodyA->GetWorldCenter().y)/LH_PTM_RATIO);
        
        posB = b2Vec2((bodyB->GetWorldCenter().x)/LH_PTM_RATIO, 
                      (bodyB->GetWorldCenter().y)/LH_PTM_RATIO);					
    }
	
	if(0 != bodyA && 0 != bodyB)
	{
		switch (type)
		{
			case LH_DISTANCE_JOINT:
			{
				//LHDistanceJoint* dJoint = (LHDistanceJoint*)joint;
				b2DistanceJointDef jointDef;
				
				jointDef.Initialize(bodyA, 
									bodyB, 
									posA,
									posB);
				
				jointDef.collideConnected = collideConnected;
				
				jointDef.frequencyHz = [[joint objectForKey:@"Frequency"] floatValue];
				jointDef.dampingRatio = [[joint objectForKey:@"Damping"] floatValue];
				                
				if(0 != world)
				{
					boxJoint = world->CreateJoint(&jointDef);
				}
			}	
				break;
				
			case LH_REVOLUTE_JOINT:
			{
				b2RevoluteJointDef jointDef;
				
				jointDef.Initialize(bodyA, bodyB, posA);
				
//				jointDef.referenceAngle = DEGREES_TO_RADIANS([[joint objectForKey:@"RefAngle"] floatValue]);
				jointDef.lowerAngle = DEGREES_TO_RADIANS([[joint objectForKey:@"LowerAngle"] floatValue]);
				jointDef.upperAngle = DEGREES_TO_RADIANS([[joint objectForKey:@"UpperAngle"] floatValue]);
				jointDef.motorSpeed = [[joint objectForKey:@"MotorSpeed"] floatValue]; //Usually in radians per second. ?????
				jointDef.maxMotorTorque = [[joint objectForKey:@"MaxTorque"] floatValue]; //Usually in N-m.  ?????
				jointDef.enableLimit = [[joint objectForKey:@"EnableLimit"] boolValue];
				jointDef.enableMotor = [[joint objectForKey:@"EnableMotor"] boolValue];
				                
				if(0 != world)
				{
					boxJoint = world->CreateJoint(&jointDef);
				}
			}
				break;
				
			case LH_PRISMATIC_JOINT:
				break;
				
			case LH_PULLEY_JOINT:
				break;
				
			case LH_GEAR_JOINT:
				break;
				
			case LH_LINE_JOINT:
				break;
				
			case LH_WELD_JOINT:
				break;
				
			default:
				NSLog(@"Unknown joint type in LevelHelper file.");
				break;
		}
	}
    
    LHJoint* jData = new LHJoint;
    jData->tag = tag;
    jData->type = (LH_JOINT_TYPE)type;
    jData->uniqueName = [joint objectForKey:@"UniqueName"];
    boxJoint->SetUserData(jData);
    

	
	return 0;
}
////////////////////////////////////////////////////////////////////////////////////
-(void)loadLevelHelperSceneFile:(NSString*)levelFile inDirectory:(NSString*)subfolder imgSubfolder:(NSString*)imgFolder
{
	NSString *path = [[NSBundle mainBundle] pathForResource:levelFile ofType:@"plhs" inDirectory:subfolder]; 
	
	NSAssert(nil!=path, @"Invalid level file. Please add the LevelHelper scene file to Resource folder. Please do not add extension in the given string.");
	
	NSDictionary *dictionary = [NSDictionary dictionaryWithContentsOfFile:path];
	
	[self processLevelFileFromDictionary:dictionary];
}

-(void)loadLevelHelperSceneFileFromWebAddress:(NSString*)webaddress
{	
	NSURL *url = [NSURL URLWithString:webaddress];
	
	NSDictionary *dictionary = [NSDictionary dictionaryWithContentsOfURL:url];
		
	if(dictionary == nil)
		NSLog(@"Provided web address is wrong or connection error.");
	
	[self processLevelFileFromDictionary:dictionary];
}

-(CGPoint) convertRatio
{
    return convertRatio;
}

-(void)processLevelFileFromDictionary:(NSDictionary*)dictionary
{
	bool fileInCorrectFormat =	[[dictionary objectForKey:@"Author"] isEqualToString:@"Bogdan Vladu"] && 
	[[dictionary objectForKey:@"CreatedWith"] isEqualToString:@"LevelHelper"];
	
	if(fileInCorrectFormat == false)
		NSLog(@"This file was not created with LevelHelper or file is damaged.");
	
    NSDictionary* scenePref = [dictionary objectForKey:@"ScenePreference"];
    safeFrame = LHPointFromString([scenePref objectForKey:@"SafeFrame"]);
    
    gameWorldRect = LHRectFromString([scenePref objectForKey:@"GameWorld"]);
    
    if(convertLevel)
    {
        CGSize winSize = [[CCDirector sharedDirector] winSize];
                
        convertRatio.x = winSize.width/safeFrame.x;
        convertRatio.y = winSize.height/safeFrame.y;
        
        float safeFrameDiagonal = sqrtf(safeFrame.x* safeFrame.x + safeFrame.y* safeFrame.y);
        float winDiagonal = sqrtf(winSize.width* winSize.width + winSize.height*winSize.height);
        float PTM_conversion = winDiagonal/safeFrameDiagonal;
                        
        [LevelHelperLoader setMeterRatio:LH_PTM_RATIO*PTM_conversion];
    }
    
	////////////////////////LOAD WORLD BOUNDARIES//////////////////////////////////////////////
	if(nil != [dictionary objectForKey:@"WBInfo"])
	{
		wb = [dictionary objectForKey:@"WBInfo"];
	}
	
	////////////////////////LOAD SPRITES////////////////////////////////////////////////////
    lhSprites = [[NSArray alloc] initWithArray:[dictionary objectForKey:@"SPRITES_INFO"]];
	
	///////////////////////////LOAD BATCH IMAGES////////////////////////////////////////////
	NSArray* batchImages = [dictionary objectForKey:@"LoadedImages"];
	for(NSDictionary* imageInfo in batchImages)
	{
		NSMutableDictionary* batchInfo = [[NSMutableDictionary alloc] init];
		
        NSString* image = [imageInfo objectForKey:@"Image"];//[self imagePath:];        
		
		CCSpriteBatchNode *batch = [CCSpriteBatchNode batchNodeWithFile:[self imageFile:image]];//
															   //capacity:BATCH_NODE_CAPACITY];	
		
		[batchInfo setObject:batch forKey:@"CCBatchNode"];
		[batchInfo setObject:[imageInfo objectForKey:@"OrderZ"] forKey:@"OrderZ"];
		
		
		[batchNodes setObject:batchInfo forKey:[imageInfo objectForKey:@"Image"]];
		[batchInfo release];
	}
	
	///////////////////////LOAD JOINTS//////////////////////////////////////////////////////////
	lhJoints = [[NSArray alloc] initWithArray:[dictionary objectForKey:@"JOINTS_INFO"]];	

    //////////////////////LOAD PARALLAX/////////////////////////////////////////
    lhParallax = [[NSArray alloc] initWithArray:[dictionary objectForKey:@"PARALLAX_INFO"]];
    
    ////////////////////LOAD BEZIER/////////////////////////////////////////////
    lhBeziers = [[NSArray alloc] initWithArray:[dictionary objectForKey:@"BEZIER_INFO"]];
    
    ////////////////////LOAD ANIMS//////////////////////////////////////////////
    lhAnims = [[NSArray alloc] initWithArray:[dictionary objectForKey:@"ANIMS_INFO"]];
    
    gravity = LHPointFromString([dictionary objectForKey:@"Gravity"]);
}
////////////////////////////////////////////////////////////////////////////////////
@end
